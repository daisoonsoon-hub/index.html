<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>離島鎮守府 脱出行（PWA 1file v2）</title>
<style>
  :root{
    --bg:#0e0f12; --panel:#171a20; --panel2:#12141a; --line:#2a2f3a;
    --txt:#e9edf4; --muted:#a9b2c3; --accent:#69c0ff; --danger:#ff6b6b; --ok:#7CFF7C;
    --btn:#232836; --btn2:#2b3142;
    --r:14px;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--txt);font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans JP",sans-serif}
  header{padding:10px 12px;border-bottom:1px solid var(--line);background:linear-gradient(180deg,var(--panel),var(--panel2))}
  header .title{font-weight:800;font-size:16px}
  header .sub{color:var(--muted);font-size:12px;margin-top:2px}
  main{padding:12px;display:flex;flex-direction:column;gap:10px;min-height:calc(100vh - 56px)}
  .row{display:flex;gap:10px;align-items:stretch}
  .col{flex:1;display:flex;flex-direction:column;gap:10px;min-width:0}
  .card{background:var(--panel);border:1px solid var(--line);border-radius:var(--r);overflow:hidden}
  .card .hd{padding:10px 10px;border-bottom:1px solid var(--line);display:flex;gap:8px;align-items:center;justify-content:space-between}
  .card .hd .h{font-weight:800}
  .card .bd{padding:10px}
  .pill{display:inline-flex;gap:6px;align-items:center;padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);color:var(--muted);font-size:12px}
  .pill b{color:var(--txt)}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  button{
    width:100%;border:1px solid rgba(255,255,255,.10);background:var(--btn);color:var(--txt);
    padding:10px 8px;border-radius:12px;font-weight:750;letter-spacing:.02em;
    transition:.08s transform,.08s background;
  }
  button:active{transform:scale(.99);background:var(--btn2)}
  button[disabled]{opacity:.35}
  .log{height:44vh;overflow:auto;line-height:1.6}
  .log .sep{margin:10px 0;border-top:1px dashed rgba(255,255,255,.15)}
  .muted{color:var(--muted)}
  .danger{color:var(--danger)}
  .ok{color:var(--ok)}
  .small{font-size:12px}
  .right{margin-left:auto}
  .tag{display:inline-block;font-size:11px;color:var(--muted);border:1px solid rgba(255,255,255,.12);padding:2px 6px;border-radius:999px;margin-left:6px}
  .hr{height:1px;background:var(--line);margin:10px 0}

  /* Image */
  .sceneImg{height:150px;border-radius:14px;border:1px solid rgba(255,255,255,.10);overflow:hidden;background:#0b0c10}
  .sceneImg img{width:100%;height:100%;object-fit:cover;display:block;opacity:.95}

  /* Modal */
  .modalWrap{position:fixed;inset:0;background:rgba(0,0,0,.62);display:none;align-items:flex-end;justify-content:center;padding:12px}
  .modalWrap.show{display:flex}
  .modal{
    width:min(760px,100%);max-height:82vh;overflow:auto;
    background:var(--panel);border:1px solid var(--line);border-radius:18px;
    box-shadow:0 14px 50px rgba(0,0,0,.45);
  }
  .modal .top{padding:12px;border-bottom:1px solid var(--line);display:flex;align-items:center;gap:10px}
  .modal .top .t{font-weight:900}
  .modal .top .x{margin-left:auto;width:auto;padding:8px 10px;border-radius:12px}
  .modal .body{padding:12px}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:12px;background:rgba(20,22,28,.95);border:1px solid rgba(255,255,255,.12);padding:10px 12px;border-radius:14px;display:none}
  .toast.show{display:block}
</style>
</head>
<body>
<header>
  <div class="title">離島鎮守府 脱出行</div>
  <div class="sub">コマンド → 対象選択式 / 有限資源 / 調査で対象増殖 / 「脱走疑い」以後は捕縛圧</div>
</header>

<main>
  <div class="card">
    <div class="hd">
      <div class="h" id="placeName">—</div>
      <div class="pill"><span>ターン</span> <b id="turn">0</b></div>
      <div class="pill"><span>警戒</span> <b id="alert">10</b></div>
      <div class="pill"><span>燃料</span> <b id="fuel">25</b></div>
      <button class="right" style="width:auto" id="btnMenu">MENU</button>
    </div>

    <div class="bd">
      <div class="sceneImg" title="背景（後で差し替え可）"><img id="sceneImg" alt="scene"></div>
      <div class="hr"></div>

      <div class="grid2">
        <div>
          <div class="small muted">目的</div>
          <div id="objective" style="margin-top:4px">—</div>
          <div class="hr"></div>
          <div class="small muted">現在地の状況</div>
          <div id="situation" style="margin-top:4px">—</div>
        </div>
        <div>
          <div class="small muted">出現中</div>
          <div id="present" style="margin-top:4px">—</div>
          <div class="hr"></div>
          <div class="small muted">同行</div>
          <div id="party" style="margin-top:4px">—</div>
          <div class="hr"></div>
          <div class="small muted">所持品</div>
          <div id="inv" style="margin-top:4px">—</div>
        </div>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="col card">
      <div class="hd"><div class="h">ログ</div><div class="small muted">（新しいほど下）</div></div>
      <div class="bd log" id="log"></div>
    </div>

    <div class="col" style="max-width:440px">
      <div class="card">
        <div class="hd"><div class="h">コマンド</div><div class="small muted">押す→対象選択</div></div>
        <div class="bd"><div class="grid3" id="cmdGrid"></div></div>
      </div>

      <div class="card">
        <div class="hd"><div class="h">艦娘</div><div class="small muted">信頼/親密（敵にも味方にも）</div></div>
        <div class="bd" id="chars"></div>
      </div>
    </div>
  </div>
</main>

<!-- Target Modal -->
<div class="modalWrap" id="modalWrap">
  <div class="modal">
    <div class="top">
      <div class="t" id="modalTitle">—</div>
      <button class="x" id="modalClose">閉じる</button>
    </div>
    <div class="body">
      <div class="small muted" id="modalHint">—</div>
      <div class="hr"></div>
      <div class="grid2" id="targetGrid"></div>
    </div>
  </div>
</div>

<!-- Menu Modal -->
<div class="modalWrap" id="menuWrap">
  <div class="modal">
    <div class="top">
      <div class="t">MENU</div>
      <button class="x" id="menuClose">閉じる</button>
    </div>
    <div class="body">
      <div class="grid2">
        <button id="btnSave">セーブ（端末）</button>
        <button id="btnLoad">ロード（端末）</button>
        <button id="btnRestart">最初から</button>
        <button id="btnReplay">同条件で最初から（seed維持）</button>
      </div>
      <div class="hr"></div>
      <div class="small muted">
        ・端末セーブは localStorage 使用。<br>
        ・同条件リプレイは調整に便利。<br>
      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
/* =========================
   Data
========================= */
const CMD = [
  {id:"move", label:"移動", hint:"移動先を選ぶ"},
  {id:"examine", label:"調べる", hint:"場所/物/人物を調べる（調べるほど対象が増える）"},
  {id:"touch", label:"触る", hint:"装置/扉/人物に触れる（場にいる艦娘も対象）"},
  {id:"hide", label:"隠れる", hint:"警戒を下げる。脱走疑いを薄める"},
  {id:"pickup", label:"拾う", hint:"発見済みの物だけ拾える（有限）"},
  {id:"drop", label:"捨てる", hint:"所持枠整理"},
  {id:"talk", label:"話す", hint:"会話で信頼/親密。状況によっては詰問される"},
  {id:"use", label:"使う", hint:"アイテム/装置に使う"},
  {id:"order", label:"命令", hint:"強い指示。状況を動かすが反発も"},
  {id:"run", label:"逃げる", hint:"離脱。脱走疑いが濃くなる"},
  {id:"apologize", label:"謝る", hint:"空気を戻す。しつこいと逆効果"},
  {id:"fight", label:"闘う", hint:"交戦。音は残る。捕縛圧が上がる"},
];

const CHAR = {
  shigure:{name:"時雨", style:"静かな観察", orderMin:25},
  asashio:{name:"朝潮", style:"規律と忠誠", orderMin:15},
  kasumi:{name:"霞", style:"辛口の現実", orderMin:45},
  takao:{name:"高雄", style:"筋を通す", orderMin:25},
  kongo:{name:"金剛", style:"勢いと明るさ", orderMin:30},
  hatsuzuki:{name:"初月", style:"合理主義", orderMin:25},
  urakaze:{name:"浦風", style:"気遣いと調整", orderMin:20},
  ikazuchi:{name:"雷", style:"元気と距離近め", orderMin:30},
  hibiki:{name:"響", style:"寡黙で鋭い", orderMin:20},
};

// 画像（内蔵SVG。あとで好きな画像URL/データURIに差し替え可能）
function svgScene(title, a="#0b1020", b="#131a2d", accent="#69c0ff"){
  const svg = `
<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="600">
  <defs>
    <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0" stop-color="${a}"/>
      <stop offset="1" stop-color="${b}"/>
    </linearGradient>
  </defs>
  <rect width="1200" height="600" fill="url(#g)"/>
  <circle cx="980" cy="120" r="70" fill="${accent}" opacity="0.18"/>
  <circle cx="1060" cy="180" r="110" fill="${accent}" opacity="0.10"/>
  <path d="M0,430 C250,350 420,520 650,455 C870,390 960,520 1200,430 L1200,600 L0,600 Z"
        fill="#0a0c12" opacity="0.65"/>
  <path d="M0,470 C260,390 430,560 650,500 C880,435 960,570 1200,470"
        fill="#000" opacity="0.25"/>
  <text x="36" y="70" fill="#e9edf4" font-size="44" font-family="system-ui, sans-serif" opacity="0.92">${title}</text>
  <text x="38" y="110" fill="#a9b2c3" font-size="22" font-family="system-ui, sans-serif" opacity="0.85">離島鎮守府 — 夜の海</text>
</svg>`;
  return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
}

const LOC = {
  hq:{name:"司令室", exits:["radio","workshop","storage","quarters","watch"], danger:6, img:()=>svgScene("司令室", "#0a0f1b","#151b2b"),
      situation:["海図が黒い。机の角が冷える。","紙の匂いが残っている。"], objects:["机","海図","書類棚"]},
  radio:{name:"無線室", exits:["hq","watch"], danger:10, img:()=>svgScene("無線室", "#080d18","#121a2e"),
      situation:["ノイズが薄く、逆に不気味だ。","ランプの瞬きが規則正しい。"], objects:["受信機","アンテナ基部","暗号表の引き出し"]},
  workshop:{name:"工廠", exits:["hq","dock","generator"], danger:9, img:()=>svgScene("工廠", "#0a0d12","#1b1f2a"),
      situation:["油と金属。工具は整然としている。","床に擦れ跡が多い。"], objects:["作業台","工具箱","予備部材棚"]},
  storage:{name:"資材庫", exits:["hq","dock","warehouse"], danger:11, img:()=>svgScene("資材庫", "#0b0b12","#1a1724"),
      situation:["棚の影が深い。箱の隙間が黒い。","湿った木箱が並ぶ。"], objects:["戸棚","棚","木箱"]},
  quarters:{name:"居住区", exits:["hq","mess","bath"], danger:7, img:()=>svgScene("居住区", "#0d0f14","#1a2230"),
      situation:["生活の匂い。気配が出やすい。","寝台が整いすぎている。"], objects:["寝台","私物箱","カーテン"]},
  mess:{name:"食堂", exits:["quarters","hq"], danger:6, img:()=>svgScene("食堂", "#0c1016","#17212a"),
      situation:["食器の音が残っている気がする。","配膳口の奥が暗い。"], objects:["テーブル","配膳口","貯水槽"]},
  watch:{name:"見張り台", exits:["hq","radio","yard"], danger:12, img:()=>svgScene("見張り台", "#060c16","#14243a"),
      situation:["風が冷たい。視界が利くぶん危ない。","海がこちらを見ている。"], objects:["双眼鏡","警鐘","照明スイッチ"]},
  yard:{name:"中庭", exits:["watch","dock","armory","tunnel"], danger:13, img:()=>svgScene("中庭", "#070b12","#1b1a26"),
      situation:["砂利が足音を売る。","外灯が揺れて影が伸びる。"], objects:["外灯","通路","排水溝"]},
  armory:{name:"兵装庫", exits:["yard","dock"], danger:14, img:()=>svgScene("兵装庫", "#0b0b10","#20161a"),
      situation:["金属臭が強い。扉が重い。","物が多く隠れやすいが危険。"], objects:["兵装棚","木箱","固定具"]},
  dock:{name:"埠頭", exits:["yard","workshop","storage","armory","tunnel"], danger:16, img:()=>svgScene("埠頭", "#050a12","#0f2032"),
      situation:["波が硬い音を立てる。出るならここだ。","封鎖ゲートが道を塞ぐ。"], objects:["輸送船","封鎖ゲート","繋留杭"]},
  bath:{name:"浴場", exits:["quarters"], danger:8, img:()=>svgScene("浴場", "#0d0c14","#1b1b2a"),
      situation:["湿気が残る。足音が吸われる。","湯気の名残が視界を鈍らせる。"], objects:["脱衣棚","洗い場","鏡"]},
  tunnel:{name:"連絡坑道", exits:["dock","yard","generator"], danger:15, img:()=>svgScene("連絡坑道", "#080a10","#14161d"),
      situation:["狭い。距離が近い。","配管の温度が高い。"], objects:["配管","点検口","ケーブル"]},
  generator:{name:"発電室", exits:["workshop","tunnel"], danger:17, img:()=>svgScene("発電室", "#070a10","#10151f"),
      situation:["低い振動。音は隠れ蓑にもなる。","機械の唸りが耳に残る。"], objects:["発電機","制御盤","換気扇"]},
  warehouse:{name:"外倉庫", exits:["yard","storage"], danger:14, img:()=>svgScene("外倉庫", "#0a0a12","#1b1a2a"),
      situation:["鉄扉が湿って滑る。","外気が冷たく、気配が鋭い。"], objects:["鉄扉","パレット","防水シート"]},
};

// アイテム（このゲームでは「調査→発見→拾う」で初めて入手）
const ITEMS = {
  scrap:{name:"部品片", desc:"工廠の整備に使える（有限）"},
  gate_key:{name:"ゲート鍵", desc:"埠頭の封鎖ゲート解除"},
  codebook:{name:"暗号表", desc:"無線照合を安定させる"},
  fuel_can:{name:"燃料缶", desc:"燃料+8（有限）"},
  cloth_tag:{name:"タグ付き布片", desc:"脱衣棚から出る。持っていると追跡が鈍ることがある"},
};

const END = {
  normal:"【ノーマルエンド】本土に帰投した。",
  bad:"【バッドエンド】捕縛され、脱走は止められた。",
  harem:"【ハーレムエンド】多くの艦娘と強い関係を築いたまま結末を迎えた。",
  king:"【王エンド】全員との関係を完成させ、結末を統べた。",
  dream:"【胡蝶の夢提督エンド】誰にも気取られず、静かに渡り切った。",
};

/* =========================
   RNG (seed)
========================= */
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296;}}
let seed = (Date.now()>>>0) ^ 0xA5A5A5A5;
let rnd = mulberry32(seed);
const rint = (n)=>Math.floor(rnd()*n);
const chance = (p)=>rnd()*100 < p;
const clamp=(v,min=0,max=100)=>Math.max(min,Math.min(max,v));

/* =========================
   Game State
========================= */
function defaultState(){
  const chars = {};
  Object.keys(CHAR).forEach(id=>{
    chars[id] = {id, name:CHAR[id].name, trust:50, intimacy:0, bonded:false, met:false, mood:"中立"};
  });

  // ロケーションごとの「有限資源/発見状態」
  const locState = {};
  Object.keys(LOC).forEach(lid=>{
    locState[lid] = {
      examined:new Set(), // 調べた対象
      touched:new Set(),  // 触った対象
      revealed:new Set(), // 発見済みの「拾える対象」
      depleted:new Set(), // 枯渇した資源
    };
  });

  return {
    seed,
    turn:0,
    alert:10,
    fuel:25,
    inventory:[], invLimit:8,
    location:"hq",
    present:[],           // 出現中（その場にいる）
    party:[],             // 同行（明示的に加入した艦娘のみ）
    flags:new Set(),      // detected_once, route_confirmed, ship_repaired, has_gate_key, gate_opened, escaped_mainland, captured...
    chars,
    locState,
    log:[],
    ended:false,
    ending:null,
  };
}
let S = defaultState();

/* =========================
   UI helpers
========================= */
const logEl = document.getElementById("log");
function pushLog(line, cls=""){
  const div=document.createElement("div");
  if(cls) div.className=cls;
  div.innerHTML=line;
  logEl.appendChild(div);
  logEl.scrollTop = logEl.scrollHeight + 9999;
  S.log.push({line,cls});
  if(S.log.length>320) S.log.shift();
}
function sep(){ pushLog('<div class="sep"></div>'); }

function toast(msg){
  const t=document.getElementById("toast");
  t.textContent=msg;
  t.classList.add("show");
  setTimeout(()=>t.classList.remove("show"), 1200);
}

function bondedCount(){
  const ids=Object.keys(S.chars);
  const b=ids.filter(id=>S.chars[id].bonded).length;
  return [b, ids.length];
}

function objectiveText(){
  const a=[];
  a.push(S.flags.has("route_confirmed")?`<span class="ok">航路：確定</span>`:`<span class="muted">航路：未確定（無線室）</span>`);
  a.push(S.flags.has("has_gate_key")?`<span class="ok">鍵：確保</span>`:`<span class="muted">鍵：未確保（資材庫/浴場）</span>`);
  a.push(S.flags.has("ship_repaired")?`<span class="ok">整備：完了</span>`:`<span class="muted">整備：未完（工廠）</span>`);
  a.push(S.flags.has("gate_opened")?`<span class="ok">封鎖：解除</span>`:`<span class="muted">封鎖：未解除（埠頭）</span>`);
  a.push(S.fuel>=30?`<span class="ok">燃料：十分</span>`:`<span class="muted">燃料：不足（有限）</span>`);
  return a.join(" / ");
}

function situationText(){
  const L=LOC[S.location];
  const s=L.situation[rint(L.situation.length)];
  const pressure = L.danger + Math.floor(S.alert/10) + (S.flags.has("detected_once")?2:0);
  const p = pressure>=22?`<span class="danger">捕縛圧：高</span>`: pressure>=16?`<span class="muted">捕縛圧：中</span>`:`<span class="ok">捕縛圧：低</span>`;
  const suspect = S.flags.has("detected_once") ? `<span class="tag">脱走疑い</span>` : `<span class="tag">未疑惑</span>`;
  return `${s} ${suspect} <span class="tag">${p}</span>`;
}

function presentText(){
  if(!S.present.length) return `<span class="muted">—</span>`;
  return S.present.map(id=>`<b>${CHAR[id].name}</b>`).join(" / ");
}

function partyText(){
  if(!S.party.length) return `<span class="muted">—</span>`;
  return S.party.map(id=>`<b>${CHAR[id].name}</b>`).join(" / ");
}

function invText(){
  if(!S.inventory.length) return `<span class="muted">なし</span>`;
  return S.inventory.map(it=>`<span class="pill"><b>${ITEMS[it]?.name ?? it}</b></span>`).join(" ");
}

function stanceOf(id){
  const t=S.chars[id].trust;
  if(t>=75) return "味方寄り";
  if(t<=35) return "敵対寄り";
  return "中立";
}

function renderChars(){
  const box=document.getElementById("chars");
  const ids=Object.keys(S.chars);
  const rows=ids.map(id=>{
    const c=S.chars[id];
    const bond = c.bonded?`<span class="tag ok">深い関係</span>`:"";
    const met = c.met?`<span class="tag">接触</span>`:"";
    const inParty = S.party.includes(id)?`<span class="tag">同行</span>`:"";
    return `
      <div style="padding:8px 0;border-bottom:1px solid rgba(255,255,255,.08)">
        <div style="display:flex;gap:8px;align-items:center">
          <b>${c.name}</b> ${met} ${inParty} ${bond}
          <span class="right small muted">信頼 ${c.trust} / 親密 ${c.intimacy}</span>
        </div>
        <div class="small muted">立場: ${stanceOf(id)} / 傾向: ${CHAR[id].style}</div>
      </div>
    `;
  }).join("");
  box.innerHTML = `<div>${rows}</div>`;
}

function renderTop(){
  document.getElementById("placeName").textContent = LOC[S.location].name;
  document.getElementById("turn").textContent = S.turn;
  document.getElementById("alert").textContent = S.alert;
  document.getElementById("fuel").textContent = S.fuel;
  document.getElementById("objective").innerHTML = objectiveText();
  document.getElementById("situation").innerHTML = situationText();
  document.getElementById("present").innerHTML = presentText();
  document.getElementById("party").innerHTML = partyText();
  document.getElementById("inv").innerHTML = invText();
  document.getElementById("sceneImg").src = LOC[S.location].img();
  renderChars();
}

/* =========================
   Encounter & Pools
========================= */
function locationPool(loc){
  const all=Object.keys(CHAR);
  const bias={
    hq:["shigure","asashio","kasumi"],
    radio:["hatsuzuki","shigure","hibiki"],
    workshop:["takao","urakaze","hatsuzuki"],
    storage:["ikazuchi","hibiki","kasumi"],
    quarters:["kasumi","kongo","ikazuchi","urakaze"],
    mess:["kongo","urakaze","ikazuchi"],
    watch:["hatsuzuki","hibiki","shigure"],
    yard:["asashio","takao","shigure","hibiki"],
    armory:["takao","asashio","hatsuzuki"],
    dock:["asashio","kasumi","takao","hibiki"],
    bath:["kongo","ikazuchi","urakaze"],
    tunnel:["hibiki","shigure","hatsuzuki"],
    generator:["hatsuzuki","hibiki"],
    warehouse:["kasumi","takao","ikazuchi"],
  }[loc] || [];
  return [...bias, ...all, ...bias];
}

function refreshPresent(force=false){
  // 「絶対会わない」防止：基本 1人以上を確保
  const pool = locationPool(S.location);
  let count = chance(45)?2:1;
  if(force) count = Math.max(1, count);

  const pick=[];
  for(let k=0;k<40 && pick.length<count;k++){
    const id=pool[rint(pool.length)];
    if(!pick.includes(id) && !S.party.includes(id)) pick.push(id);
  }
  S.present = pick;

  // 同行者がいる場合は、出現中に表示しない（別枠）
}

function enterLocation(loc){
  S.location = loc;
  refreshPresent(true);
  sep();
  pushLog(`—— <b>${LOC[loc].name}</b> ——`);
  pushLog(`<span class="muted">${LOC[loc].situation[rint(LOC[loc].situation.length)]}</span>`);
  renderTop();
}

/* =========================
   Command -> Target UI
========================= */
const cmdGrid=document.getElementById("cmdGrid");
const modalWrap=document.getElementById("modalWrap");
const modalTitle=document.getElementById("modalTitle");
const modalHint=document.getElementById("modalHint");
const targetGrid=document.getElementById("targetGrid");
document.getElementById("modalClose").onclick=()=>closeTarget();
let pendingCmd=null;

function buildCmdButtons(){
  cmdGrid.innerHTML = CMD.map(c=>`<button data-c="${c.id}">${c.label}</button>`).join("");
  cmdGrid.querySelectorAll("button").forEach(b=>{
    b.onclick=()=>openTarget(b.dataset.c);
  });
}
buildCmdButtons();

function openTarget(cmdId){
  if(S.ended) return toast("エンド後はMENUからやり直し");
  pendingCmd = cmdId;
  const cmd = CMD.find(c=>c.id===cmdId);
  modalTitle.textContent = `対象を選択：${cmd.label}`;
  modalHint.textContent = cmd.hint;

  const targets = buildTargets(cmdId);
  targetGrid.innerHTML = targets.map(t=>{
    return `<button data-t="${t.id}">${t.label}${t.tag?`<span class="tag">${t.tag}</span>`:""}</button>`;
  }).join("");

  targetGrid.querySelectorAll("button").forEach(b=>{
    b.onclick=()=>{ runCommand(pendingCmd, b.dataset.t); };
  });

  modalWrap.classList.add("show");
}
function closeTarget(){
  modalWrap.classList.remove("show");
  pendingCmd=null;
}
document.getElementById("modalWrap").addEventListener("click",(e)=>{
  if(e.target.id==="modalWrap") closeTarget();
});

function uniqTargets(arr){
  const seen=new Set();
  return arr.filter(x=>{
    const k=x.id+"|"+x.label;
    if(seen.has(k)) return false;
    seen.add(k); return true;
  });
}

function buildTargets(cmdId){
  const L=LOC[S.location];
  const LS=S.locState[S.location];
  const t=[];

  if(cmdId==="move"){
    L.exits.forEach(e=>t.push({id:`loc:${e}`, label:`${LOC[e].name}へ`, tag:"移動"}));
    return t;
  }

  // 人物（出現中 + 同行）を分けて対象化
  if(["talk","order","apologize"].includes(cmdId)){
    if(!S.present.length && !S.party.length) return [{id:"none", label:"（誰もいない）"}];
    if(S.present.length){
      t.push({id:"sep", label:"— 出現中 —", tag:""});
      S.present.forEach(id=>t.push({id:`ch:${id}`, label:CHAR[id].name, tag:stanceOf(id)}));
    }
    if(S.party.length){
      t.push({id:"sep2", label:"— 同行 —", tag:""});
      S.party.forEach(id=>t.push({id:`ch:${id}`, label:CHAR[id].name, tag:"同行"}));
    }
    return t;
  }

  // 調べる / 触る：物 + 人物（その場にいる時だけ）
  if(["examine","touch"].includes(cmdId)){
    L.objects.forEach(o=>{
      const done = LS.examined.has(o) || LS.touched.has(o);
      t.push({id:`obj:${o}`, label:o, tag:done?"済":"場所"});
    });

    // 調査で増える「派生対象」（revealed）
    [...LS.revealed].forEach(r=>{
      if(r.startsWith("sub:")){
        const name=r.slice(4);
        t.push({id:`sub:${name}`, label:name, tag:"発見"});
      }
    });

    // その場の人物も対象に
    if(S.present.length){
      t.push({id:"sep", label:"— 艦娘 —", tag:""});
      S.present.forEach(id=>t.push({id:`ch:${id}`, label:CHAR[id].name, tag:stanceOf(id)}));
    }
    if(S.party.length){
      t.push({id:"sep2", label:"— 同行 —", tag:""});
      S.party.forEach(id=>t.push({id:`ch:${id}`, label:CHAR[id].name, tag:"同行"}));
    }
    return uniqTargets(t);
  }

  // 拾う：reveal済みの「拾える物」だけ
  if(cmdId==="pickup"){
    const items = [...LS.revealed].filter(r=>r.startsWith("item:")).map(r=>r.slice(5));
    if(!items.length) return [{id:"none", label:"（拾える物がない）"}];
    items.forEach(it=>{
      if(!S.inventory.includes(it)) t.push({id:`pick:${it}`, label:ITEMS[it]?.name ?? it, tag:"拾う"});
    });
    return t.length? t : [{id:"none", label:"（拾える物がない）"}];
  }

  // 使う：所持品 + その場の装置ショートカット
  if(cmdId==="use"){
    if(S.inventory.length){
      S.inventory.forEach(it=>t.push({id:`it:${it}`, label:ITEMS[it]?.name ?? it, tag:"所持"}));
    }
    if(S.location==="dock") t.push({id:"use:gate", label:"封鎖ゲートに使う", tag:"解除"});
    if(S.location==="dock") t.push({id:"use:ship", label:"輸送船を動かす", tag:"脱出"});
    if(S.location==="radio") t.push({id:"use:radio", label:"無線照合を進める", tag:"航路"});
    if(S.location==="workshop") t.push({id:"use:repair", label:"整備を進める", tag:"整備"});
    return t.length? t : [{id:"none", label:"（使えるものがない）"}];
  }

  if(cmdId==="hide"){
    return [
      {id:"hide:shadow", label:"物陰に隠れる", tag:"警戒↓"},
      {id:"hide:still", label:"息を殺す", tag:"疑い↓"},
    ];
  }

  if(cmdId==="run"){
    return [
      {id:"run:back", label:"引く", tag:"疑い↑"},
      {id:"run:cut", label:"迂回する", tag:"警戒↑"},
    ];
  }

  if(cmdId==="fight"){
    return [
      {id:"fight:short", label:"短い衝突", tag:"音"},
      {id:"fight:break", label:"突破", tag:"危険"},
    ];
  }

  if(cmdId==="drop"){
    if(!S.inventory.length) return [{id:"none", label:"（捨てる物がない）"}];
    return S.inventory.map(it=>({id:`drop:${it}`, label:`${ITEMS[it]?.name ?? it}を捨てる`, tag:"整理"}));
  }

  return [{id:"none", label:"（対象なし）"}];
}

/* =========================
   Core logic
========================= */
function hasItem(it){ return S.inventory.includes(it); }
function addItem(it){
  if(S.inventory.includes(it)) return;
  if(S.inventory.length >= S.invLimit){ pushLog("（所持枠がいっぱいだ）", "danger"); return; }
  S.inventory.push(it);
  pushLog(`（入手：${ITEMS[it]?.name ?? it}）`, "muted");
}
function removeItem(it){
  const i=S.inventory.indexOf(it);
  if(i>=0) S.inventory.splice(i,1);
}

function markDetected(why){
  if(!S.flags.has("detected_once")){
    S.flags.add("detected_once");
    pushLog(`空気が変わる。<span class="danger">脱走疑い</span>が立った。${why?`<span class="muted">（${why}）</span>`:""}`, "danger");
  }
}

function runCommand(cmdId, targetId){
  closeTarget();
  if(S.ended) return;

  // 見出し行のセパレータは選べない
  if(targetId==="sep" || targetId==="sep2"){ toast("対象を選んで"); return; }

  S.turn++;

  // コマンドごとのベース警戒
  const baseAlert = {
    fight:+16, touch:+5, run:+9, hide:-8, order:+2, pickup:+0, move:+2, examine:+1, talk:0, apologize:-1, use:+1, drop:0
  }[cmdId] ?? 0;
  S.alert = clamp(S.alert + baseAlert);

  if(targetId==="none"){
    pushLog("うまくいかない。", "muted");
    afterStep();
    return;
  }

  // 移動
  if(cmdId==="move" && targetId.startsWith("loc:")){
    const next=targetId.slice(4);
    pushLog(`移動… <span class="muted">${LOC[next].name}</span>`);
    // 移動で疑いが立つことがある（危険地ほど）
    const p = 6 + LOC[next].danger/2 + (S.flags.has("detected_once")?6:0);
    if(chance(p)){
      markDetected("動線を読まれた");
      S.alert = clamp(S.alert+6);
    }
    enterLocation(next);
    afterStep();
    return;
  }

  // 調べる
  if(cmdId==="examine"){
    examineEvent(targetId);
    afterStep();
    return;
  }

  // 触る
  if(cmdId==="touch"){
    touchEvent(targetId);
    afterStep();
    return;
  }

  // 拾う
  if(cmdId==="pickup" && targetId.startsWith("pick:")){
    const it=targetId.slice(5);
    pickupEvent(it);
    afterStep();
    return;
  }

  // 使う
  if(cmdId==="use"){
    useEvent(targetId);
    afterStep();
    return;
  }

  // 会話/命令/謝罪
  if(["talk","order","apologize"].includes(cmdId) && targetId.startsWith("ch:")){
    const id=targetId.slice(3);
    socialEvent(cmdId, id);
    afterStep();
    return;
  }

  // 隠れる
  if(cmdId==="hide"){
    pushLog("身を潜める。", "muted");
    S.alert = clamp(S.alert - (targetId==="hide:still"?12:8));
    // 息を殺すは「疑い」を薄める（ただし完全には消さない）
    if(targetId==="hide:still" && chance(28)){
      pushLog("気配が薄れる。視線が散った。", "ok");
      // detected_once を消さずに「捕縛イベント確率」を下げるためのフラグを立てる
      S.flags.add("cooled_once");
    }
    afterStep();
    return;
  }

  // 逃げる
  if(cmdId==="run"){
    pushLog("距離を取る。背中に視線が刺さる。", "muted");
    markDetected("逃げ腰を見せた");
    S.alert = clamp(S.alert + (targetId==="run:cut"?10:7));
    afterStep();
    return;
  }

  // 闘う
  if(cmdId==="fight"){
    markDetected("衝突した");
    S.alert = clamp(S.alert + (targetId==="fight:break"?18:12));
    pushLog("短い衝突。勝っても、音は残る。", "danger");
    if(chance(60)){
      pushLog("押し返した。だが包囲は締まる。", "muted");
    }else{
      pushLog("押される。次の一手が重くなる。", "danger");
      if(chance(20)) S.flags.add("captured");
    }
    afterStep();
    return;
  }

  // 捨てる
  if(cmdId==="drop" && targetId.startsWith("drop:")){
    const it=targetId.slice(5);
    removeItem(it);
    pushLog(`（破棄：${ITEMS[it]?.name ?? it}）`, "muted");
    afterStep();
    return;
  }

  pushLog("うまくいかない。", "muted");
  afterStep();
}

/* =========================
   Deepened events
========================= */
function LS(){ return S.locState[S.location]; }

function reveal(x){ LS().revealed.add(x); }
function examined(x){ LS().examined.add(x); }
function touched(x){ LS().touched.add(x); }
function depleted(x){ LS().depleted.add(x); }

function examineEvent(targetId){
  // 人物を調べる：詰問/様子見
  if(targetId.startsWith("ch:")){
    const id=targetId.slice(3);
    const c=S.chars[id];
    c.met=true;
    pushLog(`${c.name}の様子を窺う。`, "muted");
    if(S.flags.has("detected_once") && stanceOf(id)!=="味方寄り" && chance(55)){
      pushLog(`${c.name}「……提督。いま、どこへ？」`, "danger");
      S.alert = clamp(S.alert+6);
    }else{
      pushLog(`${c.name}は視線を逸らすか、短く頷く。`, "muted");
      if(chance(35)) c.trust = clamp(c.trust+1);
    }
    return;
  }

  // 物/派生対象
  if(targetId.startsWith("obj:")){
    const obj=targetId.slice(4);
    examined(obj);
    pushLog(`調べる：<span class="muted">${obj}</span>`);

    // 場所別の“増える対象”
    // 資材庫：戸棚→鍵 / 燃料缶（有限）
    if(S.location==="storage" && obj==="戸棚"){
      if(!S.flags.has("has_gate_key")){
        pushLog("鍵束の刻印。封鎖ゲートのものだ。", "ok");
        reveal("item:gate_key");
      }else{
        pushLog("もう空だ。鍵は確保済み。", "muted");
      }
      return;
    }
    if(S.location==="storage" && obj==="木箱"){
      if(!LS().depleted.has("fuel_box")){
        pushLog("木箱の底に、油の匂い。", "muted");
        reveal("item:fuel_can");
        depleted("fuel_box"); // 1回きり
      }else{
        pushLog("空箱ばかりだ。", "muted");
      }
      return;
    }

    // 無線室：暗号表の引き出し→暗号表（有限）
    if(S.location==="radio" && obj==="暗号表の引き出し"){
      if(!hasItem("codebook") && !LS().depleted.has("codebook")){
        pushLog("紙束。暗号表だ。", "ok");
        reveal("item:codebook");
        depleted("codebook");
      }else{
        pushLog("もう見当たらない。", "muted");
      }
      return;
    }

    // 浴場：脱衣棚→布片（追跡鈍化）/鍵の痕跡（代替ルート）
    if(S.location==="bath" && obj==="脱衣棚"){
      if(!LS().depleted.has("locker")){
        pushLog("タグ付きの布片。匂いが薄く、追跡を鈍らせるかもしれない。", "ok");
        reveal("item:cloth_tag");
        // 鍵を資材庫以外でも見つけ得る（ただし確率）
        if(!S.flags.has("has_gate_key") && chance(35)){
          pushLog("奥に小さな鍵束…封鎖の刻印。", "ok");
          reveal("item:gate_key");
        }else{
          pushLog("鍵らしき痕跡はあるが、確証は薄い。", "muted");
        }
        depleted("locker");
      }else{
        pushLog("棚はもう荒らされている。", "muted");
      }
      return;
    }

    // 工廠：予備部材棚→部品片（有限）
    if(S.location==="workshop" && obj==="予備部材棚"){
      if(!LS().depleted.has("scrap")){
        pushLog("使えそうな部材。整備に回せる。", "ok");
        reveal("item:scrap");
        depleted("scrap");
      }else{
        pushLog("役立つ部材はもうない。", "muted");
      }
      return;
    }

    // 埠頭：封鎖ゲート→条件説明、輸送船→最終
    if(S.location==="dock" && obj==="封鎖ゲート"){
      pushLog("封鎖は堅い。鍵と手順が要る。", "muted");
      return;
    }
    if(S.location==="dock" && obj==="輸送船"){
      pushLog("出港できるか確認する。", "muted");
      return;
    }

    // 一般
    pushLog("手掛かりは少ない。", "muted");
    return;
  }

  if(targetId.startsWith("sub:")){
    const sub=targetId.slice(4);
    examined(sub);
    pushLog(`さらに調べる：<span class="muted">${sub}</span>`);
    pushLog("細部まで見ても、得るものは少ない。", "muted");
    return;
  }
}

function touchEvent(targetId){
  if(targetId.startsWith("ch:")){
    const id=targetId.slice(3);
    const c=S.chars[id];
    c.met=true;
    pushLog(`${c.name}に近づく。`, "muted");

    if(S.flags.has("detected_once") && stanceOf(id)!=="味方寄り" && chance(60)){
      pushLog(`${c.name}「……抵抗は、しないで」`, "danger");
      S.alert = clamp(S.alert+10);
      if(chance(40)){
        S.flags.add("captured");
        pushLog("腕を取られた。距離が消える。", "danger");
      }else{
        pushLog("間一髪で距離を取った。", "muted");
      }
    }else{
      pushLog(`${c.name}は一瞬だけ、迷うような顔をした。`, "muted");
      c.trust = clamp(c.trust + 1);
      c.intimacy = clamp(c.intimacy + 1);
    }
    return;
  }

  if(targetId.startsWith("obj:")){
    const obj=targetId.slice(4);
    touched(obj);
    pushLog(`触る：<span class="muted">${obj}</span>`);

    if(S.location==="radio" && obj==="受信機"){
      if(!S.flags.has("contact_possible")){
        pushLog("ノイズの底に符丁。繋がる“窓”がある。", "ok");
        S.flags.add("contact_possible");
      }else{
        pushLog("受信状態を整える。照合へ進めそうだ。", "muted");
      }
      return;
    }

    if(S.location==="dock" && obj==="輸送船"){
      tryEscape();
      return;
    }

    // 触るは音が出やすい
    const p = 14 + LOC[S.location].danger/2 + (S.flags.has("detected_once")?6:0);
    if(chance(p)){
      markDetected("操作音が漏れた");
      S.alert = clamp(S.alert+8);
    }else{
      pushLog("反応は薄い。", "muted");
    }
    return;
  }

  if(targetId.startsWith("sub:")){
    pushLog("触れるが、意味は薄い。", "muted");
  }
}

function pickupEvent(it){
  const LSx = LS();
  if(!LSx.revealed.has("item:"+it)){
    pushLog("まだ見つけていない。", "muted");
    return;
  }
  // 1回拾ったらその場から消える
  LSx.revealed.delete("item:"+it);

  if(it==="fuel_can"){
    pushLog("燃料缶を確保した。<span class='ok'>燃料+8</span>", "ok");
    S.fuel = Math.max(0, S.fuel + 8);
    // 燃料を持ち歩く音/匂いで疑いが立つことも
    if(chance(12)) markDetected("燃料の匂いが残った");
    return;
  }

  if(it==="gate_key"){
    pushLog("ゲート鍵を確保した。", "ok");
    S.flags.add("has_gate_key");
    addItem("gate_key");
    // 鍵取得はかなり疑われやすい
    if(chance(35)) markDetected("鍵の所在が動いた");
    return;
  }

  if(it==="codebook"){
    pushLog("暗号表を確保した。", "ok");
    addItem("codebook");
    return;
  }

  if(it==="scrap"){
    pushLog("部品片を確保した。", "ok");
    addItem("scrap");
    return;
  }

  if(it==="cloth_tag"){
    pushLog("タグ付き布片を確保した。", "ok");
    addItem("cloth_tag");
    return;
  }

  addItem(it);
}

function useEvent(targetId){
  if(targetId.startsWith("it:")){
    const it=targetId.slice(3);

    if(it==="scrap"){
      if(S.location==="workshop"){
        removeItem("scrap");
        S.flags.add("ship_repaired");
        pushLog("部品が噛み合う。機関の息が戻る。<span class='ok'>整備完了</span>", "ok");
      }else{
        pushLog("工廠で使うべきだ。", "muted");
      }
      return;
    }

    if(it==="codebook"){
      if(S.location==="radio" && S.flags.has("contact_possible")){
        S.flags.add("route_confirmed");
        pushLog("暗号表で照合。航路が確定する。<span class='ok'>航路確定</span>", "ok");
      }else{
        pushLog("無線室で照合すべきだ。", "muted");
      }
      return;
    }

    if(it==="gate_key"){
      if(S.location==="dock"){
        openGate();
      }else{
        pushLog("埠頭の封鎖ゲートで使うべきだ。", "muted");
      }
      return;
    }

    if(it==="cloth_tag"){
      pushLog("布片の匂いを散らす。追跡が鈍るかもしれない。", "muted");
      // cooled_once 相当を付与
      S.flags.add("cooled_once");
      S.alert = clamp(S.alert-3);
      return;
    }

    pushLog("使い道がない。", "muted");
    return;
  }

  if(targetId==="use:radio"){
    if(S.location!=="radio"){ pushLog("ここでは無線照合ができない。", "muted"); return; }
    if(!S.flags.has("contact_possible")){ pushLog("まず受信機を確かめる必要がある。", "muted"); return; }
    if(hasItem("codebook")){
      S.flags.add("route_confirmed");
      pushLog("照合が一気に進む。<span class='ok'>航路確定</span>", "ok");
    }else{
      if(chance(30)){
        S.flags.add("route_confirmed");
        pushLog("不安定だが照合に成功。<span class='ok'>航路確定</span>", "ok");
      }else{
        pushLog("照合が足りない。暗号表が欲しい。", "muted");
      }
    }
    return;
  }

  if(targetId==="use:repair"){
    if(S.location!=="workshop"){ pushLog("ここでは整備ができない。", "muted"); return; }
    if(S.flags.has("ship_repaired")){ pushLog("整備は完了している。", "muted"); return; }
    if(hasItem("scrap")){
      removeItem("scrap");
      S.flags.add("ship_repaired");
      pushLog("整備が通る。<span class='ok'>整備完了</span>", "ok");
    }else{
      pushLog("部品が足りない。部品片が必要だ。", "muted");
    }
    return;
  }

  if(targetId==="use:gate"){
    if(S.location!=="dock"){ pushLog("ここでは封鎖ゲートがない。", "muted"); return; }
    openGate(); return;
  }

  if(targetId==="use:ship"){
    if(S.location!=="dock"){ pushLog("ここでは出港できない。", "muted"); return; }
    tryEscape(); return;
  }

  pushLog("使えない。", "muted");
}

function openGate(){
  if(S.flags.has("gate_opened")){ pushLog("封鎖は既に解除されている。", "muted"); return; }
  if(S.flags.has("has_gate_key") || hasItem("gate_key")){
    S.flags.add("gate_opened");
    pushLog("封鎖ゲートが外れた。道が一本通る。<span class='ok'>封鎖解除</span>", "ok");
    // 解除はほぼ確で疑われる
    markDetected("封鎖が動いた");
    S.alert = clamp(S.alert+6);
  }else{
    pushLog("鍵がない。資材庫か浴場を探れ。", "muted");
  }
}

function tryEscape(){
  const need = ["route_confirmed","ship_repaired","gate_opened"];
  const miss = need.filter(f=>!S.flags.has(f));
  if(miss.length){
    pushLog("出港条件が揃っていない。", "muted");
    pushLog(`不足：<span class="danger">${miss.join(", ")}</span>`, "danger");
    return;
  }
  if(S.fuel < 30){
    pushLog("燃料が足りない。", "muted");
    return;
  }
  S.flags.add("escaped_mainland");
  pushLog("出港する。波を割り、島影が遠ざかる。", "ok");
}

function socialEvent(cmdId, id){
  const c=S.chars[id];
  c.met=true;

  const suspect = S.flags.has("detected_once");
  const stance = stanceOf(id);

  // 会話：疑われてるとまず詰問が入りやすい
  if(cmdId==="talk"){
    if(!c.met) c.met=true;
    if(suspect && stance!=="味方寄り" && chance(55)){
      pushLog(`${c.name}「提督、さっきから動きが不自然です」`, "danger");
      S.alert = clamp(S.alert+6);
      // ここで謝る/命令/隠れるに繋げる感じ
    }else{
      pushLog(talkLine(id), "muted");
      c.trust = clamp(c.trust + 2);
      c.intimacy = clamp(c.intimacy + 4);
      if(c.intimacy>=100 && !c.bonded){ c.bonded=true; pushLog(`（${c.name}との関係が深くなった）`, "ok"); }
      // たまに同行提案（信頼高い時だけ）
      if(c.trust>=75 && !S.party.includes(id) && chance(22) && S.present.includes(id)){
        pushLog(`${c.name}「……同行します。目立たないように」`, "ok");
        S.party.push(id);
        S.present = S.present.filter(x=>x!==id);
      }
    }
    return;
  }

  if(cmdId==="apologize"){
    pushLog(apologyLine(id), "muted");
    c.trust = clamp(c.trust + 4);
    c.intimacy = clamp(c.intimacy + 2);
    S.alert = clamp(S.alert-4);
    if(c.intimacy>=100 && !c.bonded){ c.bonded=true; pushLog(`（${c.name}との関係が深くなった）`, "ok"); }
    return;
  }

  if(cmdId==="order"){
    const min=CHAR[id].orderMin;
    if(c.trust < min){
      pushLog(`${c.name}は命令に渋い反応を返した。`, "muted");
      c.trust = clamp(c.trust - 2);
      S.alert = clamp(S.alert + 4);
      // 強圧は疑いを濃くする
      if(chance(30)) markDetected("強引さが目立った");
      return;
    }
    pushLog(orderLine(id), "muted");
    c.trust = clamp(c.trust + 1);

    // 同行を明示的に成立させる（勝手に同行しない）
    if(!S.party.includes(id) && S.present.includes(id) && c.trust>=70 && chance(45)){
      pushLog(`${c.name}は短く頷き、一定の距離で付いてくる。<span class="ok">同行</span>`, "ok");
      S.party.push(id);
      S.present = S.present.filter(x=>x!==id);
      return;
    }

    // 命令で目的進行が起きることもある（限定的）
    if(S.location==="radio" && !S.flags.has("route_confirmed") && chance(20)){
      S.flags.add("route_confirmed");
      pushLog("手順が整い、照合が通る。<span class='ok'>航路確定</span>", "ok");
    }
    return;
  }
}

function talkLine(id){
  // 初回は状況説明寄り、後半で戦術寄りになる
  const c=S.chars[id];
  const first = !c.met || c.intimacy<10;
  const mid = c.intimacy>=10 && c.intimacy<40;
  const late = c.intimacy>=40;

  const lines = {
    shigure:{
      first:["時雨「提督、夜は冷える。足元、気をつけて」","時雨「……何か探してる？」"],
      mid:["時雨「見張りの癖がある。動線を割ると嫌がる」","時雨「焦らなくていい。静かに積む」"],
      late:["時雨「僕は味方だよ。……でも、見つかったら止める」"],
    },
    asashio:{
      first:["朝潮「提督、指示があれば伺います」","朝潮「今夜は静かですね…」"],
      mid:["朝潮「規律を守るのが私の役目です」","朝潮「提督の意図…確認させてください」"],
      late:["朝潮「…提督の決断なら、受け止めます」"],
    },
    kasumi:{
      first:["霞「また、何か企んでる顔」","霞「いい？中途半端が一番危ない」"],
      mid:["霞「逃げるなら、逃げるで筋を通して」","霞「言い訳は後。今は手を動かしなさい」"],
      late:["霞「……止めたい。でも、提督を嫌いになれない」"],
    },
    takao:{
      first:["高雄「提督、姿勢が崩れています。落ち着いて」","高雄「状況を整理しましょう」"],
      mid:["高雄「鍵と手順。焦るほど露見します」","高雄「筋を通すなら、私が盾になります」"],
      late:["高雄「本土へ？……貴方が選ぶなら、責は共に」"],
    },
    kongo:{
      first:["金剛「Hey提督！顔、固いヨ！」","金剛「元気出すネ。でも静かにネ！」"],
      mid:["金剛「派手はダメ。今日は“我慢”の日ネ」","金剛「提督が行くなら、私も行きたい…でも」"],
      late:["金剛「止めるべきなのに、止めたくない…ズルいネ」"],
    },
    hatsuzuki:{
      first:["初月「目的は？」","初月「余計な音は出さない方がいい」"],
      mid:["初月「手順を積めば勝てる」","初月「合理的に。回り道は嫌いだ」"],
      late:["初月「…見逃す条件はある。提督次第だ」"],
    },
    urakaze:{
      first:["浦風「提督、無理しんさんな」","浦風「寒うない？」"],
      mid:["浦風「整えると、道が出るけぇ」","浦風「焦りは顔に出るよ」"],
      late:["浦風「提督を守りたい。でも、正しいとは言えん…」"],
    },
    ikazuchi:{
      first:["雷「提督！大丈夫？無理しないで！」","雷「ね、いっしょに行こ。…静かにね」"],
      mid:["雷「提督、隠れるの上手くなってきた！」","雷「でもさ…どこ行く気？」"],
      late:["雷「止めたいのに…手を握りたい」"],
    },
    hibiki:{
      first:["響「……」","響「静かに」"],
      mid:["響「足音。そこが一番危ない」","響「見られなければ、負けない」"],
      late:["響「提督。……私を置いていく？」"],
    },
  };

  const pick = first? lines[id].first : mid? lines[id].mid : lines[id].late;
  return pick[rint(pick.length)];
}

function apologyLine(id){
  const map = {
    kasumi:"霞「……まあ、謝れるだけマシ。次はちゃんと考えて」",
    asashio:"朝潮「受け取りました。提督が誠実なら、私は支えます」",
    shigure:"時雨「いいよ。でも次は同じことをしないで」",
    hibiki:"響「……分かった」",
    kongo:"金剛「No problem！取り返せばいいネ！」",
    takao:"高雄「良い判断です。落ち着きを取り戻しましょう」",
    hatsuzuki:"初月「反省は効率を上げる」",
    urakaze:"浦風「うん。大丈夫。整えていこ」",
    ikazuchi:"雷「うん！元気出して！」",
  };
  return map[id] ?? `${CHAR[id].name}は小さく頷いた。`;
}

function orderLine(id){
  const map = {
    asashio:"朝潮「了解。指示を」",
    kasumi:"霞「……責任、取ってよね」",
    hatsuzuki:"初月「合理的なら従う」",
    hibiki:"響「……了解」",
    kongo:"金剛「Okey！…音は抑えるネ」",
    takao:"高雄「承知。護ります」",
    urakaze:"浦風「うん、任せんさい」",
    ikazuchi:"雷「まかせて！」",
    shigure:"時雨「……分かった」",
  };
  return map[id] ?? `${CHAR[id].name}「……分かった」`;
}

/* =========================
   Traps / Capture pressure
========================= */
function trapCheck(){
  // 疑われてると捕縛圧が跳ねる：艦娘が「捕まえに来る」世界観
  const base = LOC[S.location].danger + Math.floor(S.alert/10) + (S.flags.has("detected_once")?6:0);
  const cool = S.flags.has("cooled_once") ? -4 : 0;
  const p = clamp(6 + base*1.2 + cool, 0, 42); // 最大42%
  if(!chance(p)) return;

  const hostile = S.flags.has("detected_once");
  const presentIds = [...S.present];
  const pick = presentIds.length? presentIds[rint(presentIds.length)] : null;

  // 追跡鈍化アイテムの影響
  const blur = hasItem("cloth_tag") ? 10 : 0;

  if(hostile && pick && chance(65 - blur)){
    pushLog(`${CHAR[pick].name}の気配が近い。<span class="danger">捕縛の動き</span>`, "danger");
    // その場で捕縛判定（簡易）。隠れる/謝るで回避しやすくなる設計。
    const evade = (hasItem("cloth_tag")?12:0) + (S.flags.has("cooled_once")?8:0) + (S.alert<30?6:0);
    if(chance(40 + evade)){
      pushLog("紙一重でやり過ごした。", "ok");
      S.alert = clamp(S.alert-3);
    }else{
      pushLog("距離が詰まる。腕を取られる。", "danger");
      if(chance(55)) S.flags.add("captured");
      else S.alert = clamp(S.alert+12);
    }
    return;
  }

  // 一般トラップ
  const pool=[
    ()=>{ markDetected("足音が拾われた"); S.alert=clamp(S.alert+10); },
    ()=>{ S.alert=clamp(S.alert+8); pushLog("停電。影が濃くなる。", "muted"); },
    ()=>{ markDetected("警報が一瞬鳴った"); S.alert=clamp(S.alert+14); },
    ()=>{ if(S.fuel>0){ S.fuel=Math.max(0,S.fuel-4); pushLog("燃料が減っている…<span class='danger'>燃料-4</span>", "danger"); } },
  ];
  pool[rint(pool.length)]();
}

function pressureCheck(){
  // 長引くほど不利
  if(S.turn > 70 && chance(12)){
    pushLog("包囲が締まっていく。", "danger");
    S.alert = clamp(S.alert+6);
  }
  if(S.alert>=100){
    S.flags.add("captured");
  }
}

/* =========================
   Ending
========================= */
function resolveEnding(){
  const escaped = S.flags.has("escaped_mainland");
  const captured = S.flags.has("captured");
  const neverDetected = !S.flags.has("detected_once");

  const [b,all]=bondedCount();
  const allBonded = (all>0 && b===all);

  if(allBonded && (escaped || captured)) return "king";
  if(b>=5 && (escaped || captured)) return "harem";
  if(escaped && neverDetected) return "dream";
  if(escaped) return "normal";
  if(captured) return "bad";
  return null;
}
function endGame(id){
  S.ended=true;
  S.ending=id;
  sep();
  pushLog(`<b>${END[id]}</b>`, id==="bad" ? "danger":"ok");
  pushLog(`<span class="muted small">MENU → 最初から / ロード で再開できます。</span>`, "muted");
}

function afterStep(){
  // 出現更新：同行は別扱い。出現は一定確率で入れ替わる
  if(!S.present.length || chance(28)) refreshPresent(true);

  trapCheck();
  pressureCheck();

  const e = resolveEnding();
  if(e) endGame(e);

  renderTop();
}

/* =========================
   Start / Save / Load
========================= */
function resetLogFromState(){
  logEl.innerHTML="";
  S.log.forEach(e=>{
    const div=document.createElement("div");
    if(e.cls) div.className=e.cls;
    div.innerHTML=e.line;
    logEl.appendChild(div);
  });
  logEl.scrollTop = logEl.scrollHeight + 9999;
}

function serialize(){
  return {
    seed:S.seed, turn:S.turn, alert:S.alert, fuel:S.fuel,
    inventory:[...S.inventory], invLimit:S.invLimit,
    location:S.location, present:[...S.present], party:[...S.party],
    flags:[...S.flags],
    chars:S.chars,
    locState:Object.fromEntries(Object.keys(S.locState).map(k=>[
      k,
      {
        examined:[...S.locState[k].examined],
        touched:[...S.locState[k].touched],
        revealed:[...S.locState[k].revealed],
        depleted:[...S.locState[k].depleted],
      }
    ])),
    log:S.log,
    ended:S.ended, ending:S.ending
  };
}
function hydrate(obj){
  seed = obj.seed ?? seed;
  rnd = mulberry32(seed);

  S = defaultState();
  S.seed=seed;
  S.turn=obj.turn??0;
  S.alert=obj.alert??10;
  S.fuel=obj.fuel??25;
  S.inventory=obj.inventory??[];
  S.invLimit=obj.invLimit??8;
  S.location=obj.location??"hq";
  S.present=obj.present??[];
  S.party=obj.party??[];
  S.flags=new Set(obj.flags??[]);
  S.chars=obj.chars??S.chars;

  if(obj.locState){
    Object.keys(obj.locState).forEach(k=>{
      const v=obj.locState[k];
      if(!S.locState[k]) return;
      S.locState[k].examined = new Set(v.examined||[]);
      S.locState[k].touched  = new Set(v.touched||[]);
      S.locState[k].revealed = new Set(v.revealed||[]);
      S.locState[k].depleted = new Set(v.depleted||[]);
    });
  }
  S.log=obj.log??[];
  S.ended=!!obj.ended;
  S.ending=obj.ending??null;

  resetLogFromState();
  renderTop();
}

function newGame(keepSeed=false){
  if(!keepSeed){
    seed = (Date.now()>>>0) ^ 0xC0FFEE;
  }
  rnd = mulberry32(seed);
  S = defaultState();
  S.seed = seed;

  pushLog("—— <b>離島鎮守府</b> ——");
  pushLog("夜の潮が重い。ここを抜け、本土へ辿り着け。<br><span class='muted'>（航路/鍵/整備/封鎖解除 → 埠頭で出港）</span>");
  enterLocation("hq");
  renderTop();
}

function saveLocal(){
  localStorage.setItem("island_escape_save", JSON.stringify(serialize()));
  toast("セーブしました");
}
function loadLocal(){
  const raw = localStorage.getItem("island_escape_save");
  if(!raw){ toast("セーブがありません"); return; }
  hydrate(JSON.parse(raw));
  toast("ロードしました");
}

document.getElementById("btnMenu").onclick=()=>document.getElementById("menuWrap").classList.add("show");
document.getElementById("menuClose").onclick=()=>document.getElementById("menuWrap").classList.remove("show");
document.getElementById("btnSave").onclick=saveLocal;
document.getElementById("btnLoad").onclick=loadLocal;
document.getElementById("btnRestart").onclick=()=>{
  document.getElementById("menuWrap").classList.remove("show");
  newGame(false);
};
document.getElementById("btnReplay").onclick=()=>{
  document.getElementById("menuWrap").classList.remove("show");
  const keep = S.seed;
  seed = keep;
  rnd = mulberry32(seed);
  S = defaultState();
  S.seed = seed;
  pushLog("—— <b>離島鎮守府</b> ——");
  pushLog("同じ潮、同じ夜。違う一手で抜けろ。<br><span class='muted'>（同条件リプレイ）</span>");
  enterLocation("hq");
  renderTop();
};
document.getElementById("menuWrap").addEventListener("click",(e)=>{
  if(e.target.id==="menuWrap") document.getElementById("menuWrap").classList.remove("show");
});

/* =========================
   Boot
========================= */
newGame(false);
</script>
</body>
</html>

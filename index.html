<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>離島鎮守府 脱出行（PWA 1file v3）</title>
<style>
  :root{
    --bg:#0e0f12; --panel:#171a20; --panel2:#12141a; --line:#2a2f3a;
    --txt:#e9edf4; --muted:#a9b2c3; --accent:#69c0ff; --danger:#ff6b6b; --ok:#7CFF7C;
    --btn:#232836; --btn2:#2b3142;
    --r:14px;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--txt);font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans JP",sans-serif}
  header{padding:10px 12px;border-bottom:1px solid var(--line);background:linear-gradient(180deg,var(--panel),var(--panel2))}
  header .title{font-weight:900;font-size:16px}
  header .sub{color:var(--muted);font-size:12px;margin-top:2px}
  main{padding:12px;display:flex;flex-direction:column;gap:10px;min-height:calc(100vh - 56px)}
  .row{display:flex;gap:10px;align-items:stretch}
  .col{flex:1;display:flex;flex-direction:column;gap:10px;min-width:0}
  .card{background:var(--panel);border:1px solid var(--line);border-radius:var(--r);overflow:hidden}
  .card .hd{padding:10px 10px;border-bottom:1px solid var(--line);display:flex;gap:8px;align-items:center;justify-content:space-between}
  .card .hd .h{font-weight:900}
  .card .bd{padding:10px}
  .pill{display:inline-flex;gap:6px;align-items:center;padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);color:var(--muted);font-size:12px}
  .pill b{color:var(--txt)}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  button{
    width:100%;border:1px solid rgba(255,255,255,.10);background:var(--btn);color:var(--txt);
    padding:10px 8px;border-radius:12px;font-weight:800;letter-spacing:.02em;
    transition:.08s transform,.08s background;
  }
  button:active{transform:scale(.99);background:var(--btn2)}
  button[disabled]{opacity:.35}
  .log{height:44vh;overflow:auto;line-height:1.65}
  .log .sep{margin:10px 0;border-top:1px dashed rgba(255,255,255,.15)}
  .muted{color:var(--muted)}
  .danger{color:var(--danger)}
  .ok{color:var(--ok)}
  .small{font-size:12px}
  .right{margin-left:auto}
  .tag{display:inline-block;font-size:11px;color:var(--muted);border:1px solid rgba(255,255,255,.12);padding:2px 6px;border-radius:999px;margin-left:6px}
  .hr{height:1px;background:var(--line);margin:10px 0}
  .sceneImg{height:150px;border-radius:14px;border:1px solid rgba(255,255,255,.10);overflow:hidden;background:#0b0c10}
  .sceneImg img{width:100%;height:100%;object-fit:cover;display:block;opacity:.95}

  .modalWrap{position:fixed;inset:0;background:rgba(0,0,0,.62);display:none;align-items:flex-end;justify-content:center;padding:12px}
  .modalWrap.show{display:flex}
  .modal{
    width:min(780px,100%);max-height:84vh;overflow:auto;
    background:var(--panel);border:1px solid var(--line);border-radius:18px;
    box-shadow:0 14px 50px rgba(0,0,0,.45);
  }
  .modal .top{padding:12px;border-bottom:1px solid var(--line);display:flex;align-items:center;gap:10px}
  .modal .top .t{font-weight:950}
  .modal .top .x{margin-left:auto;width:auto;padding:8px 10px;border-radius:12px}
  .modal .body{padding:12px}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:12px;background:rgba(20,22,28,.95);border:1px solid rgba(255,255,255,.12);padding:10px 12px;border-radius:14px;display:none}
  .toast.show{display:block}
</style>
</head>
<body>
<header>
  <div class="title">離島鎮守府 脱出行</div>
  <div class="sub">コマンド→対象選択 / “脱走疑い”が立つと捕縛行動 / 会話は選択式 / 出現時に「気づき」を明示</div>
</header>

<main>
  <div class="card">
    <div class="hd">
      <div class="h" id="placeName">—</div>
      <div class="pill"><span>ターン</span> <b id="turn">0</b></div>
      <div class="pill"><span>警戒</span> <b id="alert">10</b></div>
      <div class="pill"><span>燃料</span> <b id="fuel">25</b></div>
      <div class="pill"><span>脱走疑い</span> <b id="suspect">なし</b></div>
      <button class="right" style="width:auto" id="btnMenu">MENU</button>
    </div>

    <div class="bd">
      <div class="sceneImg" title="背景（後で差し替え可）"><img id="sceneImg" alt="scene"></div>
      <div class="hr"></div>

      <div class="grid2">
        <div>
          <div class="small muted">目的</div>
          <div id="objective" style="margin-top:4px">—</div>
          <div class="hr"></div>
          <div class="small muted">現在地の状況</div>
          <div id="situation" style="margin-top:4px">—</div>
        </div>
        <div>
          <div class="small muted">出現中</div>
          <div id="present" style="margin-top:4px">—</div>
          <div class="hr"></div>
          <div class="small muted">同行</div>
          <div id="party" style="margin-top:4px">—</div>
          <div class="hr"></div>
          <div class="small muted">所持品</div>
          <div id="inv" style="margin-top:4px">—</div>
        </div>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="col card">
      <div class="hd"><div class="h">ログ</div><div class="small muted">（新しいほど下）</div></div>
      <div class="bd log" id="log"></div>
    </div>

    <div class="col" style="max-width:440px">
      <div class="card">
        <div class="hd"><div class="h">コマンド</div><div class="small muted">押す→対象選択</div></div>
        <div class="bd"><div class="grid3" id="cmdGrid"></div></div>
      </div>

      <div class="card">
        <div class="hd"><div class="h">艦娘</div><div class="small muted">信頼/親密</div></div>
        <div class="bd" id="chars"></div>
      </div>
    </div>
  </div>
</main>

<!-- Target Modal -->
<div class="modalWrap" id="targetWrap">
  <div class="modal">
    <div class="top">
      <div class="t" id="targetTitle">—</div>
      <button class="x" id="targetClose">閉じる</button>
    </div>
    <div class="body">
      <div class="small muted" id="targetHint">—</div>
      <div class="hr"></div>
      <div class="grid2" id="targetGrid"></div>
    </div>
  </div>
</div>

<!-- Dialogue Modal -->
<div class="modalWrap" id="dlgWrap">
  <div class="modal">
    <div class="top">
      <div class="t" id="dlgTitle">会話</div>
      <button class="x" id="dlgClose">閉じる</button>
    </div>
    <div class="body">
      <div id="dlgNpcLine" style="font-weight:850"></div>
      <div class="hr"></div>
      <div class="small muted" id="dlgHint"></div>
      <div class="hr"></div>
      <div class="grid2" id="dlgChoices"></div>
    </div>
  </div>
</div>

<!-- Menu Modal -->
<div class="modalWrap" id="menuWrap">
  <div class="modal">
    <div class="top">
      <div class="t">MENU</div>
      <button class="x" id="menuClose">閉じる</button>
    </div>
    <div class="body">
      <div class="grid2">
        <button id="btnSave">セーブ（端末）</button>
        <button id="btnLoad">ロード（端末）</button>
        <button id="btnRestart">最初から</button>
        <button id="btnReplay">同条件で最初から（seed維持）</button>
      </div>
      <div class="hr"></div>
      <div class="small muted">
        ・端末セーブは localStorage 使用。<br>
        ・同条件リプレイは調整に便利。<br>
      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
/* =========================
   Commands
========================= */
const CMD = [
  {id:"move", label:"移動", hint:"移動先を選ぶ"},
  {id:"examine", label:"調べる", hint:"場所/物/人物を調べる（調べるほど対象が増える）"},
  {id:"touch", label:"触る", hint:"装置/扉/人物に触れる"},
  {id:"hide", label:"隠れる", hint:"見られている時の回避（疑いが立つことも）"},
  {id:"pickup", label:"拾う", hint:"発見済みの物だけ拾える（有限）"},
  {id:"drop", label:"捨てる", hint:"所持枠整理"},
  {id:"talk", label:"話す", hint:"会話→提督の返答選択（信頼/親密/疑いに影響）"},
  {id:"use", label:"使う", hint:"アイテム/装置に使う"},
  {id:"order", label:"命令", hint:"同行/指示など。信頼が低いと反発"},
  {id:"run", label:"逃げる", hint:"露骨な離脱行動（疑いが濃くなる）"},
  {id:"apologize", label:"謝る", hint:"空気を戻す（場面によって有効/無効）"},
  {id:"fight", label:"闘う", hint:"交戦。疑いは確定する"},
];

const CHAR = {
  shigure:{name:"時雨"},
  asashio:{name:"朝潮"},
  kasumi:{name:"霞"},
  takao:{name:"高雄"},
  kongo:{name:"金剛"},
  hatsuzuki:{name:"初月"},
  urakaze:{name:"浦風"},
  ikazuchi:{name:"雷"},
  hibiki:{name:"響"},
};

// 画像（内蔵SVG。あとで差し替え可）
function svgScene(title, a="#0b1020", b="#131a2d", accent="#69c0ff"){
  const svg = `
<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="600">
  <defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
    <stop offset="0" stop-color="${a}"/><stop offset="1" stop-color="${b}"/>
  </linearGradient></defs>
  <rect width="1200" height="600" fill="url(#g)"/>
  <circle cx="980" cy="120" r="70" fill="${accent}" opacity="0.18"/>
  <circle cx="1060" cy="180" r="110" fill="${accent}" opacity="0.10"/>
  <path d="M0,430 C250,350 420,520 650,455 C870,390 960,520 1200,430 L1200,600 L0,600 Z" fill="#0a0c12" opacity="0.65"/>
  <text x="36" y="70" fill="#e9edf4" font-size="44" font-family="system-ui, sans-serif" opacity="0.92">${title}</text>
  <text x="38" y="110" fill="#a9b2c3" font-size="22" font-family="system-ui, sans-serif" opacity="0.85">離島鎮守府 — 夜</text>
</svg>`;
  return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
}

const LOC = {
  hq:{name:"司令室", exits:["radio","workshop","storage","quarters","watch"], img:()=>svgScene("司令室", "#0a0f1b","#151b2b"),
      situation:["机の角が冷たい。","紙の匂いが残っている。"], objects:["机","海図","書類棚"]},
  radio:{name:"無線室", exits:["hq","watch"], img:()=>svgScene("無線室", "#080d18","#121a2e"),
      situation:["ノイズが薄く、逆に不気味だ。","ランプの瞬きが規則正しい。"], objects:["受信機","暗号表の引き出し"]},
  workshop:{name:"工廠", exits:["hq","dock","generator"], img:()=>svgScene("工廠", "#0a0d12","#1b1f2a"),
      situation:["油と金属の匂い。","工具の整列が逆に怖い。"], objects:["作業台","工具箱","予備部材棚"]},
  storage:{name:"資材庫", exits:["hq","dock","warehouse"], img:()=>svgScene("資材庫", "#0b0b12","#1a1724"),
      situation:["棚の影が深い。","湿った木箱が並ぶ。"], objects:["戸棚","木箱","棚"]},
  quarters:{name:"居住区", exits:["hq","mess","bath"], img:()=>svgScene("居住区", "#0d0f14","#1a2230"),
      situation:["生活の匂いが気配を呼ぶ。","寝台が整いすぎている。"], objects:["寝台","私物箱","カーテン"]},
  mess:{name:"食堂", exits:["quarters","hq"], img:()=>svgScene("食堂", "#0c1016","#17212a"),
      situation:["食器の音が残っている気がする。","配膳口の奥が暗い。"], objects:["テーブル","配膳口"]},
  watch:{name:"見張り台", exits:["hq","radio","yard"], img:()=>svgScene("見張り台", "#060c16","#14243a"),
      situation:["風が冷たい。","視界が利くぶん、気を抜けない。"], objects:["双眼鏡","照明スイッチ","警鐘"]},
  yard:{name:"中庭", exits:["watch","dock","armory","tunnel"], img:()=>svgScene("中庭", "#070b12","#1b1a26"),
      situation:["砂利が足音を売る。","外灯が揺れて影が伸びる。"], objects:["外灯","通路","排水溝"]},
  armory:{name:"兵装庫", exits:["yard","dock"], img:()=>svgScene("兵装庫", "#0b0b10","#20161a"),
      situation:["金属臭が強い。","箱が多く、隠せるが危ない。"], objects:["兵装棚","木箱","固定具"]},
  dock:{name:"埠頭", exits:["yard","workshop","storage","armory","tunnel"], img:()=>svgScene("埠頭", "#050a12","#0f2032"),
      situation:["波が硬い音を立てる。","封鎖ゲートが道を塞ぐ。"], objects:["輸送船","封鎖ゲート","繋留杭"]},
  bath:{name:"浴場", exits:["quarters"], img:()=>svgScene("浴場", "#0d0c14","#1b1b2a"),
      situation:["湿気が残る。","足音が吸われる。"], objects:["脱衣棚","洗い場","鏡"]},
  tunnel:{name:"連絡坑道", exits:["dock","yard","generator"], img:()=>svgScene("連絡坑道", "#080a10","#14161d"),
      situation:["狭い。","配管の温度が高い。"], objects:["配管","点検口","ケーブル"]},
  generator:{name:"発電室", exits:["workshop","tunnel"], img:()=>svgScene("発電室", "#070a10","#10151f"),
      situation:["低い振動が腹に響く。","機械の唸りが耳に残る。"], objects:["制御盤","発電機","換気扇"]},
  warehouse:{name:"外倉庫", exits:["yard","storage"], img:()=>svgScene("外倉庫", "#0a0a12","#1b1a2a"),
      situation:["鉄扉が湿って滑る。","外気が冷たい。"], objects:["鉄扉","パレット","防水シート"]},
};

const ITEMS = {
  scrap:{name:"部品片", desc:"工廠で整備に使う（有限）"},
  gate_key:{name:"ゲート鍵", desc:"埠頭の封鎖ゲート解除"},
  codebook:{name:"暗号表", desc:"無線照合に有利"},
  fuel_can:{name:"燃料缶", desc:"燃料+8（有限）"},
  cloth_tag:{name:"タグ付き布片", desc:"匂い/気配を散らすのに使える"},
};

const END = {
  normal:"【ノーマルエンド】本土に帰投した。",
  bad:"【バッドエンド】捕縛され、脱走は止められた。",
  harem:"【ハーレムエンド】多くの艦娘と強い関係を築いたまま結末を迎えた。",
  king:"【王エンド】全員との関係を完成させ、結末を統べた。",
  dream:"【胡蝶の夢提督エンド】一度も疑われず、静かに渡り切った。",
};

/* =========================
   RNG
========================= */
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296;}}
let seed = (Date.now()>>>0) ^ 0xA5A5A5A5;
let rnd = mulberry32(seed);
const rint = (n)=>Math.floor(rnd()*n);
const chance = (p)=>rnd()*100 < p;
const clamp=(v,min=0,max=100)=>Math.max(min,Math.min(max,v));

/* =========================
   State
========================= */
function defaultState(){
  const chars = {};
  Object.keys(CHAR).forEach(id=>{
    chars[id] = {id, name:CHAR[id].name, trust:50, intimacy:0, bonded:false, met:false};
  });

  const locState = {};
  Object.keys(LOC).forEach(lid=>{
    locState[lid] = {
      examined:new Set(),
      touched:new Set(),
      revealed:new Set(),
      depleted:new Set(),
    };
  });

  return {
    seed,
    turn:0,
    alert:10,
    fuel:25,
    inventory:[], invLimit:8,
    location:"hq",
    present:[],          // [{id, noticed:boolean}]
    party:[],            // [id...]
    suspect:false,       // 脱走疑い（立ったら艦娘は捕縛/制止に寄る）
    flags:new Set(),     // route_confirmed ship_repaired has_gate_key gate_opened escaped_mainland captured ...
    chars,
    locState,
    log:[],
    ended:false,
    ending:null,
  };
}
let S = defaultState();

/* =========================
   UI helpers
========================= */
const logEl = document.getElementById("log");
function pushLog(line, cls=""){
  const div=document.createElement("div");
  if(cls) div.className=cls;
  div.innerHTML=line;
  logEl.appendChild(div);
  logEl.scrollTop = logEl.scrollHeight + 9999;
  S.log.push({line,cls});
  if(S.log.length>320) S.log.shift();
}
function sep(){ pushLog('<div class="sep"></div>'); }
function toast(msg){
  const t=document.getElementById("toast");
  t.textContent=msg;
  t.classList.add("show");
  setTimeout(()=>t.classList.remove("show"), 1200);
}
function bondedCount(){
  const ids=Object.keys(S.chars);
  const b=ids.filter(id=>S.chars[id].bonded).length;
  return [b, ids.length];
}

function objectiveText(){
  const a=[];
  a.push(S.flags.has("route_confirmed")?`<span class="ok">航路：確定</span>`:`<span class="muted">航路：未確定（無線）</span>`);
  a.push(S.flags.has("has_gate_key")?`<span class="ok">鍵：確保</span>`:`<span class="muted">鍵：未確保（資材庫/浴場）</span>`);
  a.push(S.flags.has("ship_repaired")?`<span class="ok">整備：完了</span>`:`<span class="muted">整備：未完（工廠）</span>`);
  a.push(S.flags.has("gate_opened")?`<span class="ok">封鎖：解除</span>`:`<span class="muted">封鎖：未解除（埠頭）</span>`);
  a.push(S.fuel>=30?`<span class="ok">燃料：十分</span>`:`<span class="muted">燃料：不足</span>`);
  return a.join(" / ");
}

function situationText(){
  const L=LOC[S.location];
  const s=L.situation[rint(L.situation.length)];
  const sus = S.suspect ? `<span class="danger">脱走疑い：あり</span>` : `<span class="ok">脱走疑い：なし</span>`;
  return `${s} <span class="tag">${sus}</span>`;
}

function presentText(){
  if(!S.present.length) return `<span class="muted">—</span>`;
  return S.present.map(o=>{
    const n = o.noticed ? `<span class="tag danger">気づいてる</span>` : `<span class="tag">気づいてない</span>`;
    return `<b>${CHAR[o.id].name}</b>${n}`;
  }).join(" / ");
}

function partyText(){
  if(!S.party.length) return `<span class="muted">—</span>`;
  return S.party.map(id=>`<b>${CHAR[id].name}</b>`).join(" / ");
}

function invText(){
  if(!S.inventory.length) return `<span class="muted">なし</span>`;
  return S.inventory.map(it=>`<span class="pill"><b>${ITEMS[it]?.name ?? it}</b></span>`).join(" ");
}

function renderChars(){
  const box=document.getElementById("chars");
  const ids=Object.keys(S.chars);
  const rows=ids.map(id=>{
    const c=S.chars[id];
    const bond = c.bonded?`<span class="tag ok">深い関係</span>`:"";
    const met = c.met?`<span class="tag">接触</span>`:"";
    const inParty = S.party.includes(id)?`<span class="tag">同行</span>`:"";
    return `
      <div style="padding:8px 0;border-bottom:1px solid rgba(255,255,255,.08)">
        <div style="display:flex;gap:8px;align-items:center">
          <b>${c.name}</b> ${met} ${inParty} ${bond}
          <span class="right small muted">信頼 ${c.trust} / 親密 ${c.intimacy}</span>
        </div>
      </div>
    `;
  }).join("");
  box.innerHTML = `<div>${rows}</div>`;
}

function renderTop(){
  document.getElementById("placeName").textContent = LOC[S.location].name;
  document.getElementById("turn").textContent = S.turn;
  document.getElementById("alert").textContent = S.alert;
  document.getElementById("fuel").textContent = S.fuel;
  document.getElementById("suspect").textContent = S.suspect ? "あり" : "なし";
  document.getElementById("objective").innerHTML = objectiveText();
  document.getElementById("situation").innerHTML = situationText();
  document.getElementById("present").innerHTML = presentText();
  document.getElementById("party").innerHTML = partyText();
  document.getElementById("inv").innerHTML = invText();
  document.getElementById("sceneImg").src = LOC[S.location].img();
  renderChars();
}

/* =========================
   Encounter (present)
========================= */
function locationPool(loc){
  const all=Object.keys(CHAR);
  const bias={
    hq:["shigure","asashio","kasumi"],
    radio:["hatsuzuki","shigure","hibiki"],
    workshop:["takao","urakaze","hatsuzuki"],
    storage:["ikazuchi","hibiki","kasumi"],
    quarters:["kasumi","kongo","ikazuchi","urakaze"],
    mess:["kongo","urakaze","ikazuchi"],
    watch:["hatsuzuki","hibiki","shigure"],
    yard:["asashio","takao","shigure","hibiki"],
    armory:["takao","asashio","hatsuzuki"],
    dock:["asashio","kasumi","takao","hibiki"],
    bath:["kongo","ikazuchi","urakaze"],
    tunnel:["hibiki","shigure","hatsuzuki"],
    generator:["hatsuzuki","hibiki"],
    warehouse:["kasumi","takao","ikazuchi"],
  }[loc] || [];
  return [...bias, ...all, ...bias];
}

// “気づき”は：警戒と場所で決まる。疑いがあると気づきやすい。
function calcNoticedChance(){
  const base = 10 + Math.floor(S.alert/8) + (S.suspect?18:0);
  return clamp(base, 5, 70);
}

function refreshPresent(force=false){
  const pool = locationPool(S.location);

  // 既存の出現（同行は除外）を保持
  const existing = new Map();
  S.present.forEach(o=>{
    if(!S.party.includes(o.id)) existing.set(o.id, {id:o.id, noticed:!!o.noticed});
  });

  // 目標人数
  let count = chance(55)?2:1;
  if(force) count = Math.max(1, count);

  // まず既存を優先採用（最大countまで）
  const next = [];
  for(const o of existing.values()){
    if(next.length>=count) break;
    next.push({id:o.id, noticed:o.noticed});
  }

  // 足りない分だけ新規追加
  for(let k=0;k<80 && next.length<count;k++){
    const id = pool[rint(pool.length)];
    if(S.party.includes(id)) continue;
    if(next.some(x=>x.id===id)) continue;
    next.push({id, noticed:false});
  }

  // 新規だけ気づき抽選。既存のnoticedは維持（話したら戻らない）
  const p = calcNoticedChance();
  next.forEach(o=>{
    if(existing.has(o.id)) return;        // 既存は保持
    o.noticed = chance(p);                // 新規のみ抽選
  });

  S.present = next;
}

function enterLocation(loc){
  S.location = loc;
  refreshPresent(true);

  sep();
  pushLog(`—— <b>${LOC[loc].name}</b> ——`);
  pushLog(`<span class="muted">${LOC[loc].situation[rint(LOC[loc].situation.length)]}</span>`);

  // 出現演出（臨場感）
  if(S.present.length){
    const names = S.present.map(o=>CHAR[o.id].name).join("、");
    pushLog(`${names}がいるようだ。`, "muted");
    S.present.forEach(o=>{
      pushLog(`${CHAR[o.id].name}は… ${o.noticed ? `<span class="danger">こちらに気づいている</span>` : `<span class="muted">まだ気づいていない</span>`}。`);
      S.chars[o.id].met = true;
    });
  }else{
    pushLog("この場所には、今は誰もいない。", "muted");
  }
  renderTop();
}

/* =========================
   Command UI
========================= */
const cmdGrid=document.getElementById("cmdGrid");
const targetWrap=document.getElementById("targetWrap");
const targetTitle=document.getElementById("targetTitle");
const targetHint=document.getElementById("targetHint");
const targetGrid=document.getElementById("targetGrid");
document.getElementById("targetClose").onclick=()=>closeTarget();
let pendingCmd=null;

function buildCmdButtons(){
  cmdGrid.innerHTML = CMD.map(c=>`<button data-c="${c.id}">${c.label}</button>`).join("");
  cmdGrid.querySelectorAll("button").forEach(b=>{
    b.onclick=()=>openTarget(b.dataset.c);
  });
}
buildCmdButtons();

function openTarget(cmdId){
  if(S.ended) return toast("エンド後はMENUからやり直し");
  pendingCmd = cmdId;
  const cmd = CMD.find(c=>c.id===cmdId);
  targetTitle.textContent = `対象を選択：${cmd.label}`;
  targetHint.textContent = cmd.hint;

  const targets = buildTargets(cmdId);
  targetGrid.innerHTML = targets.map(t=>{
    const dis = t.disabled ? "disabled" : "";
    return `<button ${dis} data-t="${t.id}">${t.label}${t.tag?`<span class="tag">${t.tag}</span>`:""}</button>`;
  }).join("");

  targetGrid.querySelectorAll("button").forEach(b=>{
    b.onclick=()=>{ if(!b.disabled) runCommand(pendingCmd, b.dataset.t); };
  });

  targetWrap.classList.add("show");
}
function closeTarget(){
  targetWrap.classList.remove("show");
  pendingCmd=null;
}
targetWrap.addEventListener("click",(e)=>{
  if(e.target.id==="targetWrap") closeTarget();
});

function buildTargets(cmdId){
  const L=LOC[S.location];
  const LS=S.locState[S.location];
  const t=[];

  if(cmdId==="move"){
    L.exits.forEach(e=>t.push({id:`loc:${e}`, label:`${LOC[e].name}へ`, tag:"移動"}));
    return t;
  }

  if(["talk","order","apologize","fight"].includes(cmdId)){
    if(!S.present.length && !S.party.length) return [{id:"none", label:"（誰もいない）"}];
    if(S.present.length){
      t.push({id:"sep", label:"— 出現中 —", disabled:true});
      S.present.forEach(o=>t.push({
        id:`ch:${o.id}`, label:CHAR[o.id].name,
        tag:o.noticed? "気づいてる":"気づいてない"
      }));
    }
    if(S.party.length){
      t.push({id:"sep2", label:"— 同行 —", disabled:true});
      S.party.forEach(id=>t.push({id:`ch:${id}`, label:CHAR[id].name, tag:"同行"}));
    }
    return t;
  }

  if(["examine","touch"].includes(cmdId)){
    L.objects.forEach(o=>{
      const done = LS.examined.has(o) || LS.touched.has(o);
      t.push({id:`obj:${o}`, label:o, tag:done?"済":"場所"});
    });
    [...LS.revealed].forEach(r=>{
      if(r.startsWith("sub:")){
        const name=r.slice(4);
        t.push({id:`sub:${name}`, label:name, tag:"発見"});
      }
    });

    if(S.present.length){
      t.push({id:"sep", label:"— 艦娘 —", disabled:true});
      S.present.forEach(o=>t.push({id:`ch:${o.id}`, label:CHAR[o.id].name, tag:o.noticed? "気づいてる":"気づいてない"}));
    }
    if(S.party.length){
      t.push({id:"sep2", label:"— 同行 —", disabled:true});
      S.party.forEach(id=>t.push({id:`ch:${id}`, label:CHAR[id].name, tag:"同行"}));
    }
    return t;
  }

  if(cmdId==="pickup"){
    const items = [...LS.revealed].filter(r=>r.startsWith("item:")).map(r=>r.slice(5));
    if(!items.length) return [{id:"none", label:"（拾える物がない）"}];
    items.forEach(it=>t.push({id:`pick:${it}`, label:ITEMS[it]?.name ?? it, tag:"拾う"}));
    return t;
  }

  if(cmdId==="use"){
    if(S.inventory.length){
      S.inventory.forEach(it=>t.push({id:`it:${it}`, label:ITEMS[it]?.name ?? it, tag:"所持"}));
    }
    if(S.location==="dock"){ t.push({id:"use:gate", label:"封鎖ゲートに使う", tag:"解除"}); t.push({id:"use:ship", label:"輸送船を動かす", tag:"脱出"}); }
    if(S.location==="radio") t.push({id:"use:radio", label:"無線照合を進める", tag:"航路"});
    if(S.location==="workshop") t.push({id:"use:repair", label:"整備を進める", tag:"整備"});
    return t.length? t : [{id:"none", label:"（使えるものがない）"}];
  }

  if(cmdId==="hide"){
    return [
      {id:"hide:shadow", label:"物陰に隠れる", tag:"回避"},
      {id:"hide:still", label:"息を殺す", tag:"回避"},
    ];
  }

  if(cmdId==="run"){
    return [
      {id:"run:back", label:"引く", tag:"離脱"},
      {id:"run:cut", label:"迂回する", tag:"離脱"},
    ];
  }

  if(cmdId==="drop"){
    if(!S.inventory.length) return [{id:"none", label:"（捨てる物がない）"}];
    return S.inventory.map(it=>({id:`drop:${it}`, label:`${ITEMS[it]?.name ?? it}を捨てる`, tag:"整理"}));
  }

  return [{id:"none", label:"（対象なし）"}];
}

/* =========================
   Inventory & Flags
========================= */
function hasItem(it){ return S.inventory.includes(it); }
function addItem(it){
  if(S.inventory.includes(it)) return;
  if(S.inventory.length >= S.invLimit){ pushLog("（所持枠がいっぱいだ）", "danger"); return; }
  S.inventory.push(it);
  pushLog(`（入手：${ITEMS[it]?.name ?? it}）`, "muted");
}
function removeItem(it){
  const i=S.inventory.indexOf(it);
  if(i>=0) S.inventory.splice(i,1);
}

function setSuspect(reason){
  if(S.suspect) return;
  S.suspect = true;
  pushLog(`空気が変わる。<span class="danger">脱走を疑われた</span>。<span class="muted">（${reason}）</span>`, "danger");
}

function isSomeoneNoticed(){
  return S.present.some(o=>o.noticed);
}

/* =========================
   Location-state helpers
========================= */
function LS(){ return S.locState[S.location]; }
function reveal(x){ LS().revealed.add(x); }
function examined(x){ LS().examined.add(x); }
function touched(x){ LS().touched.add(x); }
function depleted(x){ LS().depleted.add(x); }

/* =========================
   Dialogue (talk selection)
========================= */
const dlgWrap = document.getElementById("dlgWrap");
const dlgTitle = document.getElementById("dlgTitle");
const dlgNpcLine = document.getElementById("dlgNpcLine");
const dlgHint = document.getElementById("dlgHint");
const dlgChoices = document.getElementById("dlgChoices");
document.getElementById("dlgClose").onclick=()=>dlgWrap.classList.remove("show");
dlgWrap.addEventListener("click",(e)=>{ if(e.target.id==="dlgWrap") dlgWrap.classList.remove("show"); });

let pendingAfterDialogue = null;

function openDialogue(npcId, context, npcLineText){
  const c = S.chars[npcId];
  dlgTitle.textContent = `返答を選択：${c.name}`;
  dlgHint.textContent = "提督の返答を選ぶ（選択で信頼/親密/疑いが動く）";

  const opts = dialogueOptions(npcId, context);
  dlgChoices.innerHTML = opts.map(o=>{
    const dis = o.disabled ? "disabled" : "";
    return `<button ${dis} data-k="${o.key}">${o.label}${o.tag?`<span class="tag">${o.tag}</span>`:""}</button>`;
  }).join("");

  dlgChoices.querySelectorAll("button").forEach(b=>{
    b.onclick=()=>{
      if(b.disabled) return;
      applyDialogueChoice(npcId, context, b.dataset.k);
      dlgWrap.classList.remove("show");
      if(pendingAfterDialogue){ pendingAfterDialogue(); pendingAfterDialogue=null; }
    };
  });

  dlgWrap.classList.add("show");
}

function npcLine(id, context){
  const suspect = S.suspect;
  const noticed = context.noticed;
  const base = {
    shigure: suspect ? "時雨「……提督。行き先を、聞いていい？」" : (noticed?"時雨「提督。夜更かし？」":"時雨「……誰かいるの？」"),
    asashio: suspect ? "朝潮「提督。行動理由を確認します」" : (noticed?"朝潮「提督。こんな時間に？」":"朝潮「……気配が…」"),
    kasumi: suspect ? "霞「はぁ？また逃げる気？」" : (noticed?"霞「今夜は落ち着きないわね」":"霞「……誰かいるの？」"),
    takao: suspect ? "高雄「提督。動きが不自然です。説明を」" : (noticed?"高雄「提督。お疲れですか」":"高雄「……そこですか？」"),
    kongo: suspect ? "金剛「提督！Stop！どこ行くのネ！」" : (noticed?"金剛「Hey提督！眠れない？」":"金剛「誰かいるヨ！」"),
    hatsuzuki: suspect ? "初月「提督。目的を言え」" : (noticed?"初月「提督。行動が多い」":"初月「……誰だ」"),
    urakaze: suspect ? "浦風「提督…無茶したらいけんよ」" : (noticed?"浦風「提督、寒うない？」":"浦風「…提督？」"),
    ikazuchi: suspect ? "雷「提督！待って！どこ行くの！？」" : (noticed?"雷「提督、元気ない？」":"雷「えっ、誰？」"),
    hibiki: suspect ? "響「……止まれ」" : (noticed?"響「……夜だ」":"響「……気配」"),
  }[id];

  // まだ気づいてない場合は「声かける」ニュアンスに寄せる
  if(!noticed) return base + "（こちらに気づいていない。声をかければ向く）";
  return base;
}

function dialogueOptions(id, context){
  const c=S.chars[id];
  const noticed=context.noticed;
  const opts = [];

  // 共通：無難 / 誤魔化し / 正直 / 退く
  opts.push({key:"neutral", label:"「ちょっと見回りだ」", tag:"無難"});
  opts.push({key:"lie", label:"「眠れなくて散歩してた」", tag:"誤魔化す"});
  opts.push({key:"back", label:"「悪い、戻る」", tag:"退く"});

  // 気づかれてない時：先に「声をかける/やり過ごす」
  if(!noticed){
    opts.unshift({key:"pass", label:"気づかれないようにやり過ごす", tag:"静かに"});
    opts.unshift({key:"call", label:"声をかける", tag:"接触"});
  }

  // 信頼高め：同行提案
  if(c.trust>=70 && !S.party.includes(id)){
    opts.push({key:"join", label:"「一緒に来てくれ」", tag:"同行"});
  }

  // 疑いが立ってる：謝罪/説明系を強化
  if(S.suspect){
    opts.push({key:"explain", label:"「誤解だ。理由がある」", tag:"説明"});
    opts.push({key:"apologize", label:"「疑わせたならすまない」", tag:"謝る"});
  }

  // 親密が上がってる：距離を詰める（※露骨な表現はここでは入れない）
  if(c.intimacy>=30){
    opts.push({key:"soft", label:"「心配してくれて助かる」", tag:"距離を詰める"});
  }

  return opts;
}

function applyDialogueChoice(id, context, key){
  const c=S.chars[id];
  c.met=true;

  // 会話ログ：艦娘 → 提督選択
  pushLog(`<b>${c.name}</b>：${stripHtml(dlgNpcLine.textContent)}`);
  const say = (txt)=>pushLog(`<span class="muted">提督</span>：「${txt}」`);

  // 選択の効果
  if(key==="pass"){
    say("（息を殺してやり過ごす）");
    // 成功率：警戒が低いほど成功
    const p = clamp(65 - Math.floor(S.alert/2) - (S.suspect?20:0), 10, 70);
    if(chance(p)){
      pushLog("足音が遠ざかった。", "ok");
      S.alert = clamp(S.alert-2);
      return;
    }else{
      pushLog(`${c.name}がこちらに気づいた。`, "danger");
      // 気づかれたら noticed 化
      const obj = S.present.find(o=>o.id===id);
      if(obj) obj.noticed=true;
      S.alert = clamp(S.alert+6);
      return;
    }
  }

  if(key==="call"){
    say("ちょっといいか。");
    // 声をかけたら確実に気づく
    const obj = S.present.find(o=>o.id===id);
    if(obj) obj.noticed=true;
    c.trust = clamp(c.trust+1);
    return;
  }

  if(key==="neutral"){
    say("ちょっと見回りだ。");
    if(S.suspect){
      // 疑いがあると「見回り」は逆に刺さることがある
      if(chance(35)){ pushLog(`${c.name}は納得していない。`, "danger"); S.alert=clamp(S.alert+6); }
      else { pushLog(`${c.name}「……分かった」`, "muted"); c.trust=clamp(c.trust+1); }
    }else{
      pushLog(`${c.name}「そう。気をつけて」`, "muted");
      c.trust=clamp(c.trust+2);
      c.intimacy=clamp(c.intimacy+2);
    }
    return;
  }

  if(key==="lie"){
    say("眠れなくて散歩してた。");
    const lieP = S.suspect ? 55 : 25;
    if(chance(lieP)){
      pushLog(`${c.name}「……嘘の匂いがする」`, "danger");
      S.alert=clamp(S.alert+8);
      setSuspect("言い訳が不自然");
      c.trust=clamp(c.trust-3);
    }else{
      pushLog(`${c.name}「そう…なら、少し落ち着いて」`, "muted");
      c.trust=clamp(c.trust+1);
      c.intimacy=clamp(c.intimacy+3);
    }
    return;
  }

  if(key==="back"){
    say("悪い、戻る。");
    pushLog(`${c.name}は短く頷いた。`, "muted");
    S.alert = clamp(S.alert-3);
    c.trust = clamp(c.trust+1);
    return;
  }

  if(key==="explain"){
    say("誤解だ。理由がある。");
    // 説明が通るかは信頼依存
    const p = clamp(20 + (c.trust-40), 10, 75);
    if(chance(p)){
      pushLog(`${c.name}「……話は聞く」`, "ok");
      S.alert=clamp(S.alert-6);
      c.trust=clamp(c.trust+3);
    }else{
      pushLog(`${c.name}「理由になってない」`, "danger");
      S.alert=clamp(S.alert+6);
      c.trust=clamp(c.trust-2);
    }
    return;
  }

  if(key==="apologize"){
    say("疑わせたならすまない。");
    pushLog(`${c.name}「……次は気をつけて」`, "muted");
    S.alert=clamp(S.alert-6);
    c.trust=clamp(c.trust+4);
    c.intimacy=clamp(c.intimacy+1);
    return;
  }

  if(key==="soft"){
    say("心配してくれて助かる。");
    pushLog(`${c.name}は視線を少しだけ和らげた。`, "ok");
    c.trust=clamp(c.trust+2);
    c.intimacy=clamp(c.intimacy+6);
    if(c.intimacy>=100 && !c.bonded){ c.bonded=true; pushLog(`（${c.name}との関係が深くなった）`, "ok"); }
    return;
  }

  if(key==="join"){
    say("一緒に来てくれ。");
    const p = clamp(30 + (c.trust-60) + Math.floor(c.intimacy/10), 10, 85);
    if(chance(p)){
      pushLog(`${c.name}「……分かった。距離は保つ」`, "ok");
      if(!S.party.includes(id)) S.party.push(id);
      // 出現から外す
      S.present = S.present.filter(o=>o.id!==id);
    }else{
      pushLog(`${c.name}「今は無理」`, "muted");
      c.trust=clamp(c.trust-1);
    }
    return;
  }
}

function stripHtml(s){ return (s||"").replace(/<[^>]*>/g,""); }

/* =========================
   Core command runner
========================= */
function runCommand(cmdId, targetId){
  closeTarget();
  if(S.ended) return;

  S.turn++;

  // “疑い”が立つのは「怪しい行動」だけ。
  // ただ移動しただけで疑わない。
  const suspiciousActions = new Set(["run","fight"]);
  const noiseActions = new Set(["fight"]);
  const baseAlert = {
    fight:+18, run:+10, hide:+4,
    touch:+2, pickup:+1, use:+2, order:+1,
    move:+0, examine:+0, talk:+0, apologize:-1, drop:+0
  }[cmdId] ?? 0;

  S.alert = clamp(S.alert + baseAlert);

  if(targetId==="none"){
    pushLog("うまくいかない。", "muted");
    afterStep();
    return;
  }

  if(cmdId==="move" && targetId.startsWith("loc:")){
    const next=targetId.slice(4);
    pushLog(`移動… <span class="muted">${LOC[next].name}</span>`);
    enterLocation(next);
    afterStep();
    return;
  }

  if(cmdId==="examine"){ examineEvent(targetId); afterStep(); return; }
  if(cmdId==="touch"){ touchEvent(targetId); afterStep(); return; }
  if(cmdId==="pickup" && targetId.startsWith("pick:")){ pickupEvent(targetId.slice(5)); afterStep(); return; }
  if(cmdId==="use"){ useEvent(targetId); afterStep(); return; }

  // 会話：必ず「会話モーダル→提督選択」にする
if(cmdId==="talk" && targetId.startsWith("ch:")){
  const id=targetId.slice(3);
  const obj = S.present.find(o=>o.id===id);

  // 話しかけた時点で「気づき」は確定
  if(obj) obj.noticed = true;

  // NPC台詞をログに確定出力
  const npc = npcLine(id, {noticed:true});
  pushLog(`<b>${S.chars[id].name}</b>：${stripHtml(npc)}`);

  pendingAfterDialogue = ()=>afterStep();
  openDialogue(id, {noticed:true}, npc);
  return;
}

  // 謝る（単独コマンド）は簡易に「会話」へ寄せる
  if(cmdId==="apologize" && targetId.startsWith("ch:")){
    const id=targetId.slice(3);
    pendingAfterDialogue = ()=>afterStep();
    openDialogue(id, {noticed:true, force:"apologize"});
    return;
  }

  // 命令：その場で処理（同行/反発）
  if(cmdId==="order" && targetId.startsWith("ch:")){
    const id=targetId.slice(3);
    orderEvent(id);
    afterStep();
    return;
  }

  if(cmdId==="hide"){
    hideEvent(targetId);
    afterStep();
    return;
  }

  if(cmdId==="run"){
    pushLog("距離を取る。背中に視線が刺さる。", "muted");
    setSuspect("露骨な離脱行動");
    S.alert = clamp(S.alert + 6);
    afterStep();
    return;
  }

  if(cmdId==="fight"){
    setSuspect("交戦");
    pushLog("短い衝突。勝っても、音は残る。", "danger");
    if(chance(55)){
      pushLog("押し返した。だが目は増える。", "muted");
      S.alert = clamp(S.alert+10);
    }else{
      pushLog("押される。腕を取られそうになる。", "danger");
      if(chance(35)) S.flags.add("captured");
    }
    afterStep();
    return;
  }

  if(cmdId==="drop" && targetId.startsWith("drop:")){
    const it=targetId.slice(5);
    removeItem(it);
    pushLog(`（破棄：${ITEMS[it]?.name ?? it}）`, "muted");
    afterStep();
    return;
  }

  pushLog("うまくいかない。", "muted");
  afterStep();
}

/* =========================
   Events
========================= */
function examineEvent(targetId){
  if(targetId.startsWith("ch:")){
    const id=targetId.slice(3);
    const c=S.chars[id];
    c.met=true;
    pushLog(`${c.name}の様子を窺う。`, "muted");
    const obj = S.present.find(o=>o.id===id);
    if(obj && !obj.noticed){
      pushLog(`${c.name}はまだこちらに気づいていない。`, "muted");
      return;
    }
    // 疑いがあると詰問されやすい（ただし「捕縛」はまだ）
    if(S.suspect && chance(40)){
      pushLog(`${c.name}「提督…行動が多いです」`, "danger");
      S.alert = clamp(S.alert+6);
    }else{
      pushLog(`${c.name}は短く頷くだけだ。`, "muted");
    }
    return;
  }

  if(targetId.startsWith("obj:")){
    const obj=targetId.slice(4);
    examined(obj);
    pushLog(`調べる：<span class="muted">${obj}</span>`);

    // 資材庫：戸棚→鍵
    if(S.location==="storage" && obj==="戸棚"){
      if(!S.flags.has("has_gate_key")){
        pushLog("鍵束の刻印。封鎖ゲートのものだ。", "ok");
        reveal("item:gate_key");
      }else pushLog("空だ。鍵は確保済み。", "muted");
      return;
    }

    // 資材庫：木箱→燃料缶（1回）
    if(S.location==="storage" && obj==="木箱"){
      if(!LS().depleted.has("fuel_box")){
        pushLog("木箱の底に、油の匂い。", "muted");
        reveal("item:fuel_can");
        depleted("fuel_box");
      }else pushLog("空箱ばかりだ。", "muted");
      return;
    }

    // 無線室：暗号表
    if(S.location==="radio" && obj==="暗号表の引き出し"){
      if(!hasItem("codebook") && !LS().depleted.has("codebook")){
        pushLog("紙束。暗号表だ。", "ok");
        reveal("item:codebook");
        depleted("codebook");
      }else pushLog("もう見当たらない。", "muted");
      return;
    }

    // 浴場：脱衣棚→布片、鍵チャンス
    if(S.location==="bath" && obj==="脱衣棚"){
      if(!LS().depleted.has("locker")){
        pushLog("タグ付きの布片。匂いを散らせる。", "ok");
        reveal("item:cloth_tag");
        if(!S.flags.has("has_gate_key") && chance(35)){
          pushLog("奥に小さな鍵束…封鎖の刻印。", "ok");
          reveal("item:gate_key");
        }else{
          pushLog("鍵の痕跡はあるが、確証は薄い。", "muted");
        }
        depleted("locker");
      }else pushLog("棚はもう荒らされている。", "muted");
      return;
    }

    // 工廠：部品片
    if(S.location==="workshop" && obj==="予備部材棚"){
      if(!LS().depleted.has("scrap")){
        pushLog("使えそうな部材。整備に回せる。", "ok");
        reveal("item:scrap");
        depleted("scrap");
      }else pushLog("役立つ部材はもうない。", "muted");
      return;
    }

    pushLog("手掛かりは少ない。", "muted");
    return;
  }

  if(targetId.startsWith("sub:")){
    const sub=targetId.slice(4);
    examined(sub);
    pushLog(`さらに調べる：<span class="muted">${sub}</span>`);
    pushLog("細部まで見ても、得るものは少ない。", "muted");
  }
}

function touchEvent(targetId){
  if(targetId.startsWith("ch:")){
    const id=targetId.slice(3);
    const c=S.chars[id];
    c.met=true;
    const obj=S.present.find(o=>o.id===id);
    if(obj && !obj.noticed){
      pushLog(`${c.name}に近づいた。相手はまだ気づいていない。`, "muted");
      // ここで触るのは“怪しさ”として疑いが立つ可能性
      if(chance(40)){ obj.noticed=true; pushLog(`${c.name}がこちらを向いた。`, "danger"); S.alert=clamp(S.alert+6); }
      return;
    }
    pushLog(`${c.name}に近づく。`, "muted");
    if(S.suspect && chance(35)){
      pushLog(`${c.name}「提督。距離が近い」`, "danger");
      S.alert=clamp(S.alert+6);
    }else{
      pushLog(`${c.name}は一瞬だけ迷う顔をした。`, "muted");
      c.trust=clamp(c.trust+1);
      c.intimacy=clamp(c.intimacy+2);
    }
    return;
  }

  if(targetId.startsWith("obj:")){
    const obj=targetId.slice(4);
    touched(obj);
    pushLog(`触る：<span class="muted">${obj}</span>`);

    // 無線機：照合の前提
    if(S.location==="radio" && obj==="受信機"){
      if(!S.flags.has("contact_possible")){
        pushLog("ノイズの底に符丁。繋がる“窓”がある。", "ok");
        S.flags.add("contact_possible");
      }else{
        pushLog("受信状態を整える。照合へ進めそうだ。", "muted");
      }
      return;
    }

    // 埠頭：輸送船は最終
    if(S.location==="dock" && obj==="輸送船"){
      pushLog("輸送船に手を掛ける。ここから先は“出港”だ。", "muted");
      // 出港を触るだけで疑い確定はしないが、気づかれてると危険
      if(isSomeoneNoticed() && chance(35)){
        setSuspect("埠頭での不審行動");
        S.alert=clamp(S.alert+8);
      }
      return;
    }

    // 封鎖ゲートに触れるのは怪しさ
    if(S.location==="dock" && obj==="封鎖ゲート"){
      pushLog("封鎖は堅い。鍵が要る。", "muted");
      if(isSomeoneNoticed() && chance(35)) setSuspect("封鎖ゲートに干渉");
      return;
    }

    // 触るは見られてると疑われやすい
    if(isSomeoneNoticed() && chance(25)){
      setSuspect("装置に干渉する姿を見られた");
      S.alert=clamp(S.alert+6);
    }
    return;
  }

  if(targetId.startsWith("sub:")){
    pushLog("触れるが、意味は薄い。", "muted");
  }
}

function pickupEvent(it){
  const LSx = LS();
  if(!LSx.revealed.has("item:"+it)){
    pushLog("まだ見つけていない。", "muted");
    return;
  }
  LSx.revealed.delete("item:"+it);

  if(it==="fuel_can"){
    pushLog("燃料缶を確保した。<span class='ok'>燃料+8</span>", "ok");
    S.fuel = Math.max(0, S.fuel + 8);
    // 燃料は“怪しい”にはしない（所持は普通）…ただし埠頭で見られると
    return;
  }

  if(it==="gate_key"){
    pushLog("ゲート鍵を確保した。", "ok");
    S.flags.add("has_gate_key");
    addItem("gate_key");
    // 鍵を取るのは疑いの代表
    if(isSomeoneNoticed()) setSuspect("鍵の確保を見られた");
    else if(chance(15)) setSuspect("鍵の所在が動いた");
    return;
  }

  if(it==="codebook"){
    pushLog("暗号表を確保した。", "ok");
    addItem("codebook");
    // 暗号表は単体では疑いにしない（司令の仕事にも見える）
    return;
  }

  if(it==="scrap"){
    pushLog("部品片を確保した。", "ok");
    addItem("scrap");
    // 工廠は自然、疑いにはしない
    return;
  }

  if(it==="cloth_tag"){
    pushLog("タグ付き布片を確保した。", "ok");
    addItem("cloth_tag");
    return;
  }

  addItem(it);
}

function useEvent(targetId){
  if(targetId.startsWith("it:")){
    const it=targetId.slice(3);

    if(it==="scrap"){
      if(S.location==="workshop"){
        removeItem("scrap");
        S.flags.add("ship_repaired");
        pushLog("部品が噛み合う。機関の息が戻る。<span class='ok'>整備完了</span>", "ok");
      }else pushLog("工廠で使うべきだ。", "muted");
      return;
    }

    if(it==="codebook"){
      if(S.location==="radio" && S.flags.has("contact_possible")){
        S.flags.add("route_confirmed");
        pushLog("暗号表で照合。航路が確定する。<span class='ok'>航路確定</span>", "ok");
        // 無線照合は「脱走準備」扱い。気づかれてたら疑い
        if(isSomeoneNoticed()) setSuspect("無線照合を見られた");
        else if(chance(20)) setSuspect("無線の使用履歴");
      }else pushLog("無線室で照合すべきだ。", "muted");
      return;
    }

    if(it==="gate_key"){
      if(S.location==="dock"){ openGate(); }
      else pushLog("埠頭の封鎖ゲートで使うべきだ。", "muted");
      return;
    }

    if(it==="cloth_tag"){
      pushLog("布片の匂いを散らす。気配が薄まる。", "muted");
      S.alert = clamp(S.alert-6);
      return;
    }

    pushLog("使い道がない。", "muted");
    return;
  }

  if(targetId==="use:radio"){
    if(S.location!=="radio"){ pushLog("ここでは無線照合ができない。", "muted"); return; }
    if(!S.flags.has("contact_possible")){ pushLog("まず受信機を確かめる必要がある。", "muted"); return; }
    if(hasItem("codebook")){
      S.flags.add("route_confirmed");
      pushLog("照合が通る。<span class='ok'>航路確定</span>", "ok");
    }else{
      if(chance(30)){ S.flags.add("route_confirmed"); pushLog("不安定だが照合に成功。<span class='ok'>航路確定</span>", "ok"); }
      else pushLog("照合が足りない。暗号表が欲しい。", "muted");
    }
    if(isSomeoneNoticed()) setSuspect("無線照合を見られた");
    else if(chance(20)) setSuspect("無線の使用履歴");
    return;
  }

  if(targetId==="use:repair"){
    if(S.location!=="workshop"){ pushLog("ここでは整備ができない。", "muted"); return; }
    if(S.flags.has("ship_repaired")){ pushLog("整備は完了している。", "muted"); return; }
    if(hasItem("scrap")){
      removeItem("scrap");
      S.flags.add("ship_repaired");
      pushLog("整備が通る。<span class='ok'>整備完了</span>", "ok");
    }else pushLog("部品が足りない。部品片が必要だ。", "muted");
    return;
  }

  if(targetId==="use:gate"){ if(S.location!=="dock"){ pushLog("ここでは封鎖ゲートがない。", "muted"); return; } openGate(); return; }
  if(targetId==="use:ship"){ if(S.location!=="dock"){ pushLog("ここでは出港できない。", "muted"); return; } tryEscape(); return; }

  pushLog("使えない。", "muted");
}

function openGate(){
  if(S.flags.has("gate_opened")){ pushLog("封鎖は既に解除されている。", "muted"); return; }
  if(S.flags.has("has_gate_key") || hasItem("gate_key")){
    S.flags.add("gate_opened");
    pushLog("封鎖ゲートが外れた。道が一本通る。<span class='ok'>封鎖解除</span>", "ok");
    setSuspect("封鎖解除は脱走準備に見える");
    S.alert = clamp(S.alert+8);
  }else{
    pushLog("鍵がない。資材庫か浴場を探れ。", "muted");
  }
}

function tryEscape(){
  const need = ["route_confirmed","ship_repaired","gate_opened"];
  const miss = need.filter(f=>!S.flags.has(f));
  if(miss.length){
    pushLog("出港条件が揃っていない。", "muted");
    pushLog(`不足：<span class="danger">${miss.join(", ")}</span>`, "danger");
    return;
  }
  if(S.fuel < 30){
    pushLog("燃料が足りない。", "muted");
    return;
  }
  setSuspect("出港を試みた");
  S.flags.add("escaped_mainland");
  pushLog("出港する。波を割り、島影が遠ざかる。", "ok");
}

function orderEvent(id){
  const c=S.chars[id];
  c.met=true;

  pushLog(`${c.name}に命令する。`, "muted");

  // 命令は信頼依存
  const p = clamp(10 + (c.trust-40), 5, 80);
  if(chance(p)){
    // 同行命令：明示的に同行
    if(!S.party.includes(id)){
      pushLog(`${c.name}「了解。…ただし、提督」`, "muted");
      pushLog(`${c.name}「変なことをするなら止めます」`, S.suspect?"danger":"muted");
      S.party.push(id);
      S.present = S.present.filter(o=>o.id!==id);
      c.trust=clamp(c.trust+1);
      return;
    }else{
      pushLog(`${c.name}「了解」`, "muted");
      c.trust=clamp(c.trust+1);
      return;
    }
  }else{
    pushLog(`${c.name}は頷かない。`, "danger");
    c.trust=clamp(c.trust-3);
    // 反発が目立つと疑いが濃くなることも
    if(S.suspect && chance(25)) S.alert=clamp(S.alert+6);
  }
}

function hideEvent(kind){
  pushLog("身を潜める。", "muted");
  // 隠れる自体が“怪しい”になり得る：気づかれてる時だけ疑い
  const seen = isSomeoneNoticed();
  if(seen && chance(40)) setSuspect("隠れ方が不自然");

  // 効果：気づかれてるなら“気づき”解除のチャンス
  const p = clamp(55 - Math.floor(S.alert/3) + (kind==="hide:still"?10:0), 10, 75);
  if(seen && chance(p)){
    pushLog("視線が逸れた。気配が薄まる。", "ok");
    S.present.forEach(o=>o.noticed=false);
    S.alert = clamp(S.alert-10);
  }else{
    S.alert = clamp(S.alert-6);
    pushLog("息を止める。だが心臓の音がうるさい。", "muted");
  }
}

/* =========================
   Suspect-phase: capture attempts
   ※疑いが「あり」の時だけ発生
========================= */
function captureCheck(){
  if(!S.suspect) return; // ←ここが肝。疑いなしで捕縛は起きない。

  // 同じ場所に“気づいてる艦娘”がいると止めに来る
  const noticed = S.present.filter(o=>o.noticed);
  if(!noticed.length) return;

  // 発生率：警戒が高いほど
  const p = clamp(8 + Math.floor(S.alert/8), 6, 30);
  if(!chance(p)) return;

  const o = noticed[rint(noticed.length)];
  const name = CHAR[o.id].name;

  // いきなり捕縛じゃなく「制止→捕縛」へ段階化
  pushLog(`${name}が前に出る。<span class="danger">「提督、止まって」</span>`, "danger");

  // 回避チャンス：隠れる/謝るを次手でやれ、って圧を作る
  // ここでは即ゲームオーバーにしない（理不尽回避）
  S.alert = clamp(S.alert + 8);

  // ただし警戒MAXだと捕縛
  if(S.alert>=100){
    S.flags.add("captured");
  }
}

function pressureCheck(){
  // だらだらすると警戒は少しずつ上がる
  if(S.turn > 70 && chance(12)){
    pushLog("巡回が濃くなる。", "muted");
    S.alert = clamp(S.alert+4);
  }
  if(S.alert>=100){
    S.flags.add("captured");
  }
}

/* =========================
   Ending
========================= */
function resolveEnding(){
  const escaped = S.flags.has("escaped_mainland");
  const captured = S.flags.has("captured");
  const neverSuspected = !S.suspect;

  const [b,all]=bondedCount();
  const allBonded = (all>0 && b===all);

  if(allBonded && (escaped || captured)) return "king";
  if(b>=5 && (escaped || captured)) return "harem";
  if(escaped && neverSuspected) return "dream";
  if(escaped) return "normal";
  if(captured) return "bad";
  return null;
}
function endGame(id){
  S.ended=true;
  S.ending=id;
  sep();
  pushLog(`<b>${END[id]}</b>`, id==="bad" ? "danger":"ok");
  pushLog(`<span class="muted small">MENU → 最初から / ロード で再開できます。</span>`, "muted");
}

function afterStep(){
  // 出現入れ替え：頻度は低めに（臨場感のため）
  if(chance(18)) refreshPresent(true);

  captureCheck();
  pressureCheck();

  const e = resolveEnding();
  if(e) endGame(e);

  renderTop();
}

/* =========================
   Save/Load
========================= */
function resetLogFromState(){
  logEl.innerHTML="";
  S.log.forEach(e=>{
    const div=document.createElement("div");
    if(e.cls) div.className=e.cls;
    div.innerHTML=e.line;
    logEl.appendChild(div);
  });
  logEl.scrollTop = logEl.scrollHeight + 9999;
}

function serialize(){
  return {
    seed:S.seed, turn:S.turn, alert:S.alert, fuel:S.fuel, suspect:S.suspect,
    inventory:[...S.inventory], invLimit:S.invLimit,
    location:S.location, present:[...S.present], party:[...S.party],
    flags:[...S.flags],
    chars:S.chars,
    locState:Object.fromEntries(Object.keys(S.locState).map(k=>[
      k,
      {
        examined:[...S.locState[k].examined],
        touched:[...S.locState[k].touched],
        revealed:[...S.locState[k].revealed],
        depleted:[...S.locState[k].depleted],
      }
    ])),
    log:S.log,
    ended:S.ended, ending:S.ending
  };
}
function hydrate(obj){
  seed = obj.seed ?? seed;
  rnd = mulberry32(seed);

  S = defaultState();
  S.seed=seed;
  S.turn=obj.turn??0;
  S.alert=obj.alert??10;
  S.fuel=obj.fuel??25;
  S.suspect=!!obj.suspect;
  S.inventory=obj.inventory??[];
  S.invLimit=obj.invLimit??8;
  S.location=obj.location??"hq";
  S.present=obj.present??[];
  S.party=obj.party??[];
  S.flags=new Set(obj.flags??[]);
  S.chars=obj.chars??S.chars;

  if(obj.locState){
    Object.keys(obj.locState).forEach(k=>{
      const v=obj.locState[k];
      if(!S.locState[k]) return;
      S.locState[k].examined = new Set(v.examined||[]);
      S.locState[k].touched  = new Set(v.touched||[]);
      S.locState[k].revealed = new Set(v.revealed||[]);
      S.locState[k].depleted = new Set(v.depleted||[]);
    });
  }
  S.log=obj.log??[];
  S.ended=!!obj.ended;
  S.ending=obj.ending??null;

  resetLogFromState();
  renderTop();
}

function newGame(keepSeed=false){
  if(!keepSeed){
    seed = (Date.now()>>>0) ^ 0xC0FFEE;
  }
  rnd = mulberry32(seed);
  S = defaultState();
  S.seed = seed;

  pushLog("—— <b>離島鎮守府</b> ——");
  pushLog("夜の潮が重い。ここを抜け、本土へ辿り着け。<br><span class='muted'>（航路/鍵/整備/封鎖解除 → 埠頭で出港）</span>");
  enterLocation("hq");
  renderTop();
}

function saveLocal(){
  localStorage.setItem("island_escape_save", JSON.stringify(serialize()));
  toast("セーブしました");
}
function loadLocal(){
  const raw = localStorage.getItem("island_escape_save");
  if(!raw){ toast("セーブがありません"); return; }
  hydrate(JSON.parse(raw));
  toast("ロードしました");
}

/* =========================
   Menu wiring
========================= */
document.getElementById("btnMenu").onclick=()=>document.getElementById("menuWrap").classList.add("show");
document.getElementById("menuClose").onclick=()=>document.getElementById("menuWrap").classList.remove("show");
document.getElementById("btnSave").onclick=saveLocal;
document.getElementById("btnLoad").onclick=loadLocal;
document.getElementById("btnRestart").onclick=()=>{
  document.getElementById("menuWrap").classList.remove("show");
  newGame(false);
};
document.getElementById("btnReplay").onclick=()=>{
  document.getElementById("menuWrap").classList.remove("show");
  const keep = S.seed;
  seed = keep;
  rnd = mulberry32(seed);
  S = defaultState();
  S.seed = seed;
  pushLog("—— <b>離島鎮守府</b> ——");
  pushLog("同じ潮、同じ夜。違う一手で抜けろ。<br><span class='muted'>（同条件リプレイ）</span>");
  enterLocation("hq");
  renderTop();
};
document.getElementById("menuWrap").addEventListener("click",(e)=>{
  if(e.target.id==="menuWrap") document.getElementById("menuWrap").classList.remove("show");
});

/* =========================
   Boot
========================= */
newGame(false);
</script>
</body>
</html>

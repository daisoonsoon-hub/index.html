<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>離島鎮守府 脱出行（基礎コード / セクション分け版）</title>
<style>
  :root{
    --bg:#0e0f12; --panel:#171a20; --panel2:#12141a; --line:#2a2f3a;
    --txt:#e9edf4; --muted:#a9b2c3; --accent:#69c0ff; --danger:#ff6b6b; --ok:#7CFF7C;
    --btn:#232836; --btn2:#2b3142; --r:14px;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--txt);font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans JP",sans-serif}
  header{padding:10px 12px;border-bottom:1px solid var(--line);background:linear-gradient(180deg,var(--panel),var(--panel2))}
  header .title{font-weight:900;font-size:16px}
  header .sub{color:var(--muted);font-size:12px;margin-top:2px}
  main{padding:12px;display:flex;flex-direction:column;gap:10px;min-height:calc(100vh - 56px)}
  .row{display:flex;gap:10px;align-items:stretch}
  .col{flex:1;display:flex;flex-direction:column;gap:10px;min-width:0}
  .card{background:var(--panel);border:1px solid var(--line);border-radius:var(--r);overflow:hidden}
  .card .hd{padding:10px 10px;border-bottom:1px solid var(--line);display:flex;gap:8px;align-items:center;justify-content:space-between}
  .card .hd .h{font-weight:900}
  .card .bd{padding:10px}
  .pill{display:inline-flex;gap:6px;align-items:center;padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);color:var(--muted);font-size:12px}
  .pill b{color:var(--txt)}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  button{
    width:100%;border:1px solid rgba(255,255,255,.10);background:var(--btn);color:var(--txt);
    padding:10px 8px;border-radius:12px;font-weight:800;letter-spacing:.02em;
    transition:.08s transform,.08s background;
  }
  button:active{transform:scale(.99);background:var(--btn2)}
  button[disabled]{opacity:.35}
  .log{height:44vh;overflow:auto;line-height:1.65}
  .log .sep{margin:10px 0;border-top:1px dashed rgba(255,255,255,.15)}
  .muted{color:var(--muted)}
  .danger{color:var(--danger)}
  .ok{color:var(--ok)}
  .small{font-size:12px}
  .right{margin-left:auto}
  .tag{display:inline-block;font-size:11px;color:var(--muted);border:1px solid rgba(255,255,255,.12);padding:2px 6px;border-radius:999px;margin-left:6px}
  .hr{height:1px;background:var(--line);margin:10px 0}
  .sceneImg{height:150px;border-radius:14px;border:1px solid rgba(255,255,255,.10);overflow:hidden;background:#0b0c10}
  .sceneImg img{width:100%;height:100%;object-fit:cover;display:block;opacity:.95}

  .modalWrap{position:fixed;inset:0;background:rgba(0,0,0,.62);display:none;align-items:flex-end;justify-content:center;padding:12px}
  .modalWrap.show{display:flex}
  .modal{
    width:min(780px,100%);max-height:84vh;overflow:auto;
    background:var(--panel);border:1px solid var(--line);border-radius:18px;
    box-shadow:0 14px 50px rgba(0,0,0,.45);
  }
  .modal .top{padding:12px;border-bottom:1px solid var(--line);display:flex;align-items:center;gap:10px}
  .modal .top .t{font-weight:950}
  .modal .top .x{margin-left:auto;width:auto;padding:8px 10px;border-radius:12px}
  .modal .body{padding:12px}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:12px;background:rgba(20,22,28,.95);border:1px solid rgba(255,255,255,.12);padding:10px 12px;border-radius:14px;display:none}
  .toast.show{display:block}
</style>
</head>

<body>
<header>
  <div class="title">離島鎮守府 脱出行（基礎コード / セクション分け版）</div>
  <div class="sub">修正しやすいように「定数→状態→UI→遭遇→各コマンド→会話データ」の順に整理</div>
</header>

<main>
  <div class="card">
    <div class="hd">
      <div class="h" id="placeName">—</div>
      <div class="pill"><span>ターン</span> <b id="turn">0</b></div>
      <div class="pill"><span>警戒</span> <b id="alert">10</b></div>
      <div class="pill"><span>燃料</span> <b id="fuel">25</b></div>
      <div class="pill"><span>脱走疑い</span> <b id="suspect">なし</b></div>
      <button class="right" style="width:auto" id="btnMenu">MENU</button>
    </div>

    <div class="bd">
      <div class="sceneImg"><img id="sceneImg" alt="scene"></div>
      <div class="hr"></div>

      <div class="grid2">
        <div>
          <div class="small muted">目的</div>
          <div id="objective" style="margin-top:4px">—</div>
          <div class="hr"></div>
          <div class="small muted">現在地の状況</div>
          <div id="situation" style="margin-top:4px">—</div>
        </div>
        <div>
          <div class="small muted">出現中</div>
          <div id="present" style="margin-top:4px">—</div>
          <div class="hr"></div>
          <div class="small muted">同行</div>
          <div id="party" style="margin-top:4px">—</div>
          <div class="hr"></div>
          <div class="small muted">所持品</div>
          <div id="inv" style="margin-top:4px">—</div>
        </div>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="col card">
      <div class="hd"><div class="h">ログ</div><div class="small muted">（新しいほど下）</div></div>
      <div class="bd log" id="log"></div>
    </div>

    <div class="col" style="max-width:440px">
      <div class="card">
        <div class="hd"><div class="h">コマンド</div><div class="small muted">押す→対象選択</div></div>
        <div class="bd"><div class="grid3" id="cmdGrid"></div></div>
      </div>

      <div class="card">
        <div class="hd"><div class="h">艦娘</div><div class="small muted">信頼/親密</div></div>
        <div class="bd" id="chars"></div>
      </div>
    </div>
  </div>
</main>

<!-- 対象選択モーダル -->
<div class="modalWrap" id="targetWrap">
  <div class="modal">
    <div class="top">
      <div class="t" id="targetTitle">—</div>
      <button class="x" id="targetClose">閉じる</button>
    </div>
    <div class="body">
      <div class="small muted" id="targetHint">—</div>
      <div class="hr"></div>
      <div class="grid2" id="targetGrid"></div>
    </div>
  </div>
</div>

<!-- 返答選択モーダル（NPC台詞はログに確定／返答だけ選ぶ） -->
<div class="modalWrap" id="dlgWrap">
  <div class="modal">
    <div class="top">
      <div class="t" id="dlgTitle">返答</div>
      <button class="x" id="dlgClose">閉じる</button>
    </div>
    <div class="body">
      <div class="small muted" id="dlgHint"></div>
      <div class="hr"></div>
      <div class="grid2" id="dlgChoices"></div>
    </div>
  </div>
</div>

<!-- メニュー -->
<div class="modalWrap" id="menuWrap">
  <div class="modal">
    <div class="top">
      <div class="t">MENU</div>
      <button class="x" id="menuClose">閉じる</button>
    </div>
    <div class="body">
      <div class="grid2">
        <button id="btnSave">セーブ（端末）</button>
        <button id="btnLoad">ロード（端末）</button>
        <button id="btnRestart">最初から</button>
        <button id="btnReplay">同条件で最初から（seed維持）</button>
      </div>
      <div class="hr"></div>
      <div class="small muted">
        ・端末セーブは localStorage 使用。<br>
        ・同条件リプレイは調整に便利。<br>
      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
/* =========================================================
   00) ここが「入口」：全部を一つの App にまとめる
========================================================= */
const App = (() => {

/* =========================================================
   01) 定数（世界データ）
   - ここを増やす：場所 / 艦娘 / アイテム / コマンド
========================================================= */
const CMD = [
  {id:"move", label:"移動", hint:"移動先を選ぶ"},
  {id:"examine", label:"調べる", hint:"場所/物/人物を調べる（調べるほど対象が増える）"},
  {id:"touch", label:"触る", hint:"装置/扉/人物に触れる"},
  {id:"hide", label:"隠れる", hint:"回避（見られてる時は怪しまれることも）"},
  {id:"pickup", label:"拾う", hint:"発見済みの物だけ拾える（有限）"},
  {id:"drop", label:"捨てる", hint:"所持枠整理"},
  {id:"talk", label:"話す", hint:"対象選択→NPC台詞はログ確定→返答だけ選ぶ"},
  {id:"use", label:"使う", hint:"アイテム/装置に使う"},
  {id:"order", label:"命令", hint:"同行/指示。信頼が低いと反発"},
  {id:"run", label:"逃げる", hint:"露骨な離脱行動（疑いが濃くなる）"},
  {id:"apologize", label:"謝る", hint:"空気を戻す（場面によって有効/無効）"},
  {id:"fight", label:"闘う", hint:"交戦。疑いは確定する"},
];

const CHAR = {
  shigure:{name:"時雨"},
  asashio:{name:"朝潮"},
  kasumi:{name:"霞"},
  takao:{name:"高雄"},
  kongo:{name:"金剛"},
  hatsuzuki:{name:"初月"},
  urakaze:{name:"浦風"},
  ikazuchi:{name:"雷"},
  hibiki:{name:"響"},
};

// 内蔵の簡易背景（あとで画像に差し替え可）
function svgScene(title, a="#0b1020", b="#131a2d", accent="#69c0ff"){
  const svg = `
<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="600">
  <defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
    <stop offset="0" stop-color="${a}"/><stop offset="1" stop-color="${b}"/>
  </linearGradient></defs>
  <rect width="1200" height="600" fill="url(#g)"/>
  <circle cx="980" cy="120" r="70" fill="${accent}" opacity="0.18"/>
  <circle cx="1060" cy="180" r="110" fill="${accent}" opacity="0.10"/>
  <path d="M0,430 C250,350 420,520 650,455 C870,390 960,520 1200,430 L1200,600 L0,600 Z" fill="#0a0c12" opacity="0.65"/>
  <text x="36" y="70" fill="#e9edf4" font-size="44" font-family="system-ui, sans-serif" opacity="0.92">${title}</text>
  <text x="38" y="110" fill="#a9b2c3" font-size="22" font-family="system-ui, sans-serif" opacity="0.85">離島鎮守府 — 夜</text>
</svg>`;
  return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
}

const LOC = {
  hq:{name:"司令室", exits:["radio","workshop","storage","quarters","watch"], img:()=>svgScene("司令室", "#0a0f1b","#151b2b"),
      situation:["机の角が冷たい。","紙の匂いが残っている。"], objects:["机","海図","書類棚"]},
  radio:{name:"無線室", exits:["hq","watch"], img:()=>svgScene("無線室", "#080d18","#121a2e"),
      situation:["ノイズが薄く、逆に不気味だ。","ランプの瞬きが規則正しい。"], objects:["受信機","暗号表の引き出し"]},
  workshop:{name:"工廠", exits:["hq","dock","generator"], img:()=>svgScene("工廠", "#0a0d12","#1b1f2a"),
      situation:["油と金属の匂い。","工具の整列が逆に怖い。"], objects:["作業台","工具箱","予備部材棚"]},
  storage:{name:"資材庫", exits:["hq","dock","warehouse"], img:()=>svgScene("資材庫", "#0b0b12","#1a1724"),
      situation:["棚の影が深い。","湿った木箱が並ぶ。"], objects:["戸棚","木箱","棚"]},
  quarters:{name:"居住区", exits:["hq","mess","bath"], img:()=>svgScene("居住区", "#0d0f14","#1a2230"),
      situation:["生活の匂いが気配を呼ぶ。","寝台が整いすぎている。"], objects:["寝台","私物箱","カーテン"]},
  mess:{name:"食堂", exits:["quarters","hq"], img:()=>svgScene("食堂", "#0c1016","#17212a"),
      situation:["食器の音が残っている気がする。","配膳口の奥が暗い。"], objects:["テーブル","配膳口"]},
  watch:{name:"見張り台", exits:["hq","radio","yard"], img:()=>svgScene("見張り台", "#060c16","#14243a"),
      situation:["風が冷たい。","視界が利くぶん、気を抜けない。"], objects:["双眼鏡","照明スイッチ","警鐘"]},
  yard:{name:"中庭", exits:["watch","dock","armory","tunnel"], img:()=>svgScene("中庭", "#070b12","#1b1a26"),
      situation:["砂利が足音を売る。","外灯が揺れて影が伸びる。"], objects:["外灯","通路","排水溝"]},
  armory:{name:"兵装庫", exits:["yard","dock"], img:()=>svgScene("兵装庫", "#0b0b10","#20161a"),
      situation:["金属臭が強い。","箱が多く、隠せるが危ない。"], objects:["兵装棚","木箱","固定具"]},
  dock:{name:"埠頭", exits:["yard","workshop","storage","armory","tunnel"], img:()=>svgScene("埠頭", "#050a12","#0f2032"),
      situation:["波が硬い音を立てる。","封鎖ゲートが道を塞ぐ。"], objects:["輸送船","封鎖ゲート","繋留杭"]},
  bath:{name:"浴場", exits:["quarters"], img:()=>svgScene("浴場", "#0d0c14","#1b1b2a"),
      situation:["湿気が残る。","足音が吸われる。"], objects:["脱衣棚","洗い場","鏡"]},
  tunnel:{name:"連絡坑道", exits:["dock","yard","generator"], img:()=>svgScene("連絡坑道", "#080a10","#14161d"),
      situation:["狭い。","配管の温度が高い。"], objects:["配管","点検口","ケーブル"]},
  generator:{name:"発電室", exits:["workshop","tunnel"], img:()=>svgScene("発電室", "#070a10","#10151f"),
      situation:["低い振動が腹に響く。","機械の唸りが耳に残る。"], objects:["制御盤","発電機","換気扇"]},
  warehouse:{name:"外倉庫", exits:["yard","storage"], img:()=>svgScene("外倉庫", "#0a0a12","#1b1a2a"),
      situation:["鉄扉が湿って滑る。","外気が冷たい。"], objects:["鉄扉","パレット","防水シート"]},
};

const ITEMS = {
  scrap:{name:"部品片", desc:"工廠で整備に使う（有限）"},
  gate_key:{name:"ゲート鍵", desc:"埠頭の封鎖ゲート解除"},
  codebook:{name:"暗号表", desc:"無線照合に有利"},
  fuel_can:{name:"燃料缶", desc:"燃料+8（有限）"},
  cloth_tag:{name:"タグ付き布片", desc:"匂い/気配を散らすのに使える"},
};

const END = {
  normal:"【ノーマルエンド】本土に帰投した。",
  bad:"【バッドエンド】捕縛され、脱走は止められた。",
  harem:"【ハーレムエンド】多くの艦娘と強い関係を築いたまま結末を迎えた。",
  king:"【王エンド】全員との関係を完成させ、結末を統べた。",
  dream:"【胡蝶の夢提督エンド】一度も疑われず、静かに渡り切った。",
};

/* =========================================================
   02) 乱数（seed つき）
========================================================= */
function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296;}}
let seed = (Date.now()>>>0) ^ 0xA5A5A5A5;
let rnd = mulberry32(seed);
const rint = (n)=>Math.floor(rnd()*n);
const chance = (p)=>rnd()*100 < p;
const clamp=(v,min=0,max=100)=>Math.max(min,Math.min(max,v));

/* =========================================================
   03) 状態（ゲーム進行のデータ）
   - 新しい要素は S の中に足す
========================================================= */
function defaultState(){
  const chars = {};
  Object.keys(CHAR).forEach(id=>{
    chars[id] = {id, name:CHAR[id].name, trust:50, intimacy:0, bonded:false, met:false};
  });

  const locState = {};
  Object.keys(LOC).forEach(lid=>{
    locState[lid] = {
      examined:new Set(),
      touched:new Set(),
      revealed:new Set(),  // "item:xxx" / "sub:xxx"
      depleted:new Set(),  // 取り切った箱など
    };
  });

  return {
    seed,
    turn:0,
    alert:10,
    fuel:25,
    inventory:[], invLimit:8,
    location:"hq",
    present:[],         // [{id, noticed:boolean}]
    party:[],           // [id...]
    suspect:false,      // 脱走疑い（立ったら制止/捕縛が発生）
    flags:new Set(),    // route_confirmed ship_repaired has_gate_key gate_opened escaped_mainland captured ...
    chars,
  dlg:{
  shigure:{
    thread:null,
    stage:0,
    lastTurn:0,
    metCount:0,
    topics:new Set()
  }
},

locState,
log:[],
ended:false,
ending:null,
  };
}
let S = defaultState();

/* =========================================================
   04) DOM/UI（描画とログ）
========================================================= */
const el = {
  log: document.getElementById("log"),
  placeName: document.getElementById("placeName"),
  turn: document.getElementById("turn"),
  alert: document.getElementById("alert"),
  fuel: document.getElementById("fuel"),
  suspect: document.getElementById("suspect"),
  objective: document.getElementById("objective"),
  situation: document.getElementById("situation"),
  present: document.getElementById("present"),
  party: document.getElementById("party"),
  inv: document.getElementById("inv"),
  sceneImg: document.getElementById("sceneImg"),
  chars: document.getElementById("chars"),
  cmdGrid: document.getElementById("cmdGrid"),
  toast: document.getElementById("toast"),
};

function pushLog(line, cls=""){
  const div=document.createElement("div");
  if(cls) div.className=cls;
  div.innerHTML=line;
  el.log.appendChild(div);
  el.log.scrollTop = el.log.scrollHeight + 9999;
  S.log.push({line,cls});
  if(S.log.length>320) S.log.shift();
}
function sep(){ pushLog('<div class="sep"></div>'); }
function toast(msg){
  el.toast.textContent=msg;
  el.toast.classList.add("show");
  setTimeout(()=>el.toast.classList.remove("show"), 1100);
}

function stripHtml(s){ return (s||"").replace(/<[^>]*>/g,""); }

function bondedCount(){
  const ids=Object.keys(S.chars);
  const b=ids.filter(id=>S.chars[id].bonded).length;
  return [b, ids.length];
}

function objectiveText(){
  const a=[];
  a.push(S.flags.has("route_confirmed")?`<span class="ok">航路：確定</span>`:`<span class="muted">航路：未確定（無線）</span>`);
  a.push(S.flags.has("has_gate_key")?`<span class="ok">鍵：確保</span>`:`<span class="muted">鍵：未確保（資材庫/浴場）</span>`);
  a.push(S.flags.has("ship_repaired")?`<span class="ok">整備：完了</span>`:`<span class="muted">整備：未完（工廠）</span>`);
  a.push(S.flags.has("gate_opened")?`<span class="ok">封鎖：解除</span>`:`<span class="muted">封鎖：未解除（埠頭）</span>`);
  a.push(S.fuel>=30?`<span class="ok">燃料：十分</span>`:`<span class="muted">燃料：不足</span>`);
  return a.join(" / ");
}

function situationText(){
  const L=LOC[S.location];
  const s=L.situation[rint(L.situation.length)];
  const sus = S.suspect ? `<span class="danger">脱走疑い：あり</span>` : `<span class="ok">脱走疑い：なし</span>`;
  return `${s} <span class="tag">${sus}</span>`;
}

function presentText(){
  if(!S.present.length) return `<span class="muted">—</span>`;
  return S.present.map(o=>{
    const n = o.noticed ? `<span class="tag danger">気づいてる</span>` : `<span class="tag">気づいてない</span>`;
    return `<b>${CHAR[o.id].name}</b>${n}`;
  }).join(" / ");
}
function partyText(){
  if(!S.party.length) return `<span class="muted">—</span>`;
  return S.party.map(id=>`<b>${CHAR[id].name}</b>`).join(" / ");
}
function invText(){
  if(!S.inventory.length) return `<span class="muted">なし</span>`;
  return S.inventory.map(it=>`<span class="pill"><b>${ITEMS[it]?.name ?? it}</b></span>`).join(" ");
}

function renderChars(){
  const ids=Object.keys(S.chars);
  const rows=ids.map(id=>{
    const c=S.chars[id];
    const bond = c.bonded?`<span class="tag ok">深い関係</span>`:"";
    const met = c.met?`<span class="tag">接触</span>`:"";
    const inParty = S.party.includes(id)?`<span class="tag">同行</span>`:"";
    return `
      <div style="padding:8px 0;border-bottom:1px solid rgba(255,255,255,.08)">
        <div style="display:flex;gap:8px;align-items:center">
          <b>${c.name}</b> ${met} ${inParty} ${bond}
          <span class="right small muted">信頼 ${c.trust} / 親密 ${c.intimacy}</span>
        </div>
      </div>
    `;
  }).join("");
  el.chars.innerHTML = `<div>${rows}</div>`;
}

function renderTop(){
  el.placeName.textContent = LOC[S.location].name;
  el.turn.textContent = S.turn;
  el.alert.textContent = S.alert;
  el.fuel.textContent = S.fuel;
  el.suspect.textContent = S.suspect ? "あり" : "なし";
  el.objective.innerHTML = objectiveText();
  el.situation.innerHTML = situationText();
  el.present.innerHTML = presentText();
  el.party.innerHTML = partyText();
  el.inv.innerHTML = invText();
  el.sceneImg.src = LOC[S.location].img();
  renderChars();
}

/* =========================================================
   05) ユーティリティ（所持品・フラグ・locState）
========================================================= */
function LS(){ return S.locState[S.location]; }
function hasItem(it){ return S.inventory.includes(it); }
function addItem(it){
  if(S.inventory.includes(it)) return;
  if(S.inventory.length >= S.invLimit){ pushLog("（所持枠がいっぱいだ）", "danger"); return; }
  S.inventory.push(it);
  pushLog(`（入手：${ITEMS[it]?.name ?? it}）`, "muted");
}
function removeItem(it){
  const i=S.inventory.indexOf(it);
  if(i>=0) S.inventory.splice(i,1);
}
function reveal(x){ LS().revealed.add(x); }
function examined(x){ LS().examined.add(x); }
function touched(x){ LS().touched.add(x); }
function depleted(x){ LS().depleted.add(x); }

function setSuspect(reason){
  if(S.suspect) return;
  S.suspect = true;
  pushLog(`空気が変わる。<span class="danger">脱走を疑われた</span>。<span class="muted">（${reason}）</span>`, "danger");
}
function isSomeoneNoticed(){
  return S.present.some(o=>o.noticed);
}

/* =========================================================
   06) 遭遇（出現/気づき）
   - “話したのに気づきが戻る”バグ対策済み：既存は noticed 保持
========================================================= */
function locationPool(loc){
  const all=Object.keys(CHAR);
  const bias={
    hq:["shigure","asashio","kasumi"],
    radio:["hatsuzuki","shigure","hibiki"],
    workshop:["takao","urakaze","hatsuzuki"],
    storage:["ikazuchi","hibiki","kasumi"],
    quarters:["kasumi","kongo","ikazuchi","urakaze"],
    mess:["kongo","urakaze","ikazuchi"],
    watch:["hatsuzuki","hibiki","shigure"],
    yard:["asashio","takao","shigure","hibiki"],
    armory:["takao","asashio","hatsuzuki"],
    dock:["asashio","kasumi","takao","hibiki"],
    bath:["kongo","ikazuchi","urakaze"],
    tunnel:["hibiki","shigure","hatsuzuki"],
    generator:["hatsuzuki","hibiki"],
    warehouse:["kasumi","takao","ikazuchi"],
  }[loc] || [];
  return [...bias, ...all, ...bias];
}
function calcNoticedChance(){
  const base = 10 + Math.floor(S.alert/8) + (S.suspect?18:0);
  return clamp(base, 5, 70);
}
function refreshPresent(force=false){
  const pool = locationPool(S.location);

  // 既存を保持（noticed を維持）
  const existing = new Map();
  S.present.forEach(o=>{
    if(!S.party.includes(o.id)) existing.set(o.id, {id:o.id, noticed:!!o.noticed});
  });

  let count = chance(55)?2:1;
  if(force) count = Math.max(1, count);

  const next = [];
  for(const o of existing.values()){
    if(next.length>=count) break;
    next.push({id:o.id, noticed:o.noticed});
  }

  for(let k=0;k<80 && next.length<count;k++){
    const id = pool[rint(pool.length)];
    if(S.party.includes(id)) continue;
    if(next.some(x=>x.id===id)) continue;
    next.push({id, noticed:false});
  }

  const p = calcNoticedChance();
  next.forEach(o=>{
    if(existing.has(o.id)) return; // 既存は保持
    o.noticed = chance(p);         // 新規だけ抽選
  });

  S.present = next;
}

function enterLocation(loc){
  S.location = loc;
  refreshPresent(true);

  sep();
  pushLog(`—— <b>${LOC[loc].name}</b> ——`);
  pushLog(`<span class="muted">${LOC[loc].situation[rint(LOC[loc].situation.length)]}</span>`);

  if(S.present.length){
    const names = S.present.map(o=>CHAR[o.id].name).join("、");
    pushLog(`${names}がいるようだ。`, "muted");
    S.present.forEach(o=>{
      pushLog(`${CHAR[o.id].name}は… ${o.noticed ? `<span class="danger">こちらに気づいている</span>` : `<span class="muted">まだ気づいていない</span>`}。`);
      S.chars[o.id].met = true;
    });
  }else{
    pushLog("この場所には、今は誰もいない。", "muted");
  }

  renderTop();
}

/* =========================================================
   07) 対象選択UI（コマンド→対象の一覧）
========================================================= */
const targetUI = (() => {
  const wrap=document.getElementById("targetWrap");
  const title=document.getElementById("targetTitle");
  const hint=document.getElementById("targetHint");
  const grid=document.getElementById("targetGrid");
  const closeBtn=document.getElementById("targetClose");

  let pendingCmd=null;

  function open(cmdId){
    if(S.ended) return toast("エンド後はMENUからやり直し");
    pendingCmd = cmdId;
    const cmd = CMD.find(c=>c.id===cmdId);
    title.textContent = `対象を選択：${cmd.label}`;
    hint.textContent = cmd.hint;

    const targets = buildTargets(cmdId);
    grid.innerHTML = targets.map(t=>{
      const dis = t.disabled ? "disabled" : "";
      return `<button ${dis} data-t="${t.id}">${t.label}${t.tag?`<span class="tag">${t.tag}</span>`:""}</button>`;
    }).join("");

    grid.querySelectorAll("button").forEach(b=>{
      b.onclick=()=>{ if(!b.disabled) runCommand(pendingCmd, b.dataset.t); };
    });

    wrap.classList.add("show");
  }

  function close(){
    wrap.classList.remove("show");
    pendingCmd=null;
  }

  closeBtn.onclick=close;
  wrap.addEventListener("click",(e)=>{ if(e.target.id==="targetWrap") close(); });

  return { open, close };
})();

/* =========================================================
   08) 返答選択UI（会話）
   - NPC台詞はログに確定出力
   - モーダルは「提督の返答」だけ出す
========================================================= */
const dialogueUI = (() => {
  const wrap=document.getElementById("dlgWrap");
  const title=document.getElementById("dlgTitle");
  const hint=document.getElementById("dlgHint");
  const choices=document.getElementById("dlgChoices");
  const closeBtn=document.getElementById("dlgClose");

  let after=null;

  function open(npcId, context, afterFn){
    after = afterFn || null;

    const c = S.chars[npcId];
    title.textContent = `返答を選択：${c.name}`;
    hint.textContent = "返答を選ぶ（信頼/親密/疑いが動く）";

    const opts = Dialogue.options(npcId, context);
    choices.innerHTML = opts.map(o=>{
      const dis = o.disabled ? "disabled" : "";
      return `<button ${dis} data-k="${o.key}">${o.label}${o.tag?`<span class="tag">${o.tag}</span>`:""}</button>`;
    }).join("");

    choices.querySelectorAll("button").forEach(b=>{
      b.onclick=()=>{
        if(b.disabled) return;
        Dialogue.applyChoice(npcId, context, b.dataset.k);
        wrap.classList.remove("show");
        if(after){ const fn=after; after=null; fn(); }
      };
    });

    wrap.classList.add("show");
  }

  function close(){
    wrap.classList.remove("show");
    after=null;
  }

  closeBtn.onclick=close;
  wrap.addEventListener("click",(e)=>{ if(e.target.id==="dlgWrap") close(); });

  return { open, close };
})();

/* =========================================================
   09) 対象一覧生成（コマンド別）
   - 追加/改造が一番多い場所
========================================================= */
function buildTargets(cmdId){
  const L=LOC[S.location];
  const st=LS();
  const t=[];

  if(cmdId==="move"){
    L.exits.forEach(e=>t.push({id:`loc:${e}`, label:`${LOC[e].name}へ`, tag:"移動"}));
    return t;
  }

  if(["talk","order","apologize","fight"].includes(cmdId)){
    if(!S.present.length && !S.party.length) return [{id:"none", label:"（誰もいない）"}];
    if(S.present.length){
      t.push({id:"sep", label:"— 出現中 —", disabled:true});
      S.present.forEach(o=>t.push({
        id:`ch:${o.id}`, label:CHAR[o.id].name,
        tag:o.noticed? "気づいてる":"気づいてない"
      }));
    }
    if(S.party.length){
      t.push({id:"sep2", label:"— 同行 —", disabled:true});
      S.party.forEach(id=>t.push({id:`ch:${id}`, label:CHAR[id].name, tag:"同行"}));
    }
    return t;
  }

  if(["examine","touch"].includes(cmdId)){
    L.objects.forEach(o=>{
      const done = st.examined.has(o) || st.touched.has(o);
      t.push({id:`obj:${o}`, label:o, tag:done?"済":"場所"});
    });

    [...st.revealed].forEach(r=>{
      if(r.startsWith("sub:")){
        const name=r.slice(4);
        t.push({id:`sub:${name}`, label:name, tag:"発見"});
      }
    });

    if(S.present.length){
      t.push({id:"sep", label:"— 艦娘 —", disabled:true});
      S.present.forEach(o=>t.push({id:`ch:${o.id}`, label:CHAR[o.id].name, tag:o.noticed? "気づいてる":"気づいてない"}));
    }
    if(S.party.length){
      t.push({id:"sep2", label:"— 同行 —", disabled:true});
      S.party.forEach(id=>t.push({id:`ch:${id}`, label:CHAR[id].name, tag:"同行"}));
    }
    return t;
  }

  if(cmdId==="pickup"){
    const items = [...st.revealed].filter(r=>r.startsWith("item:")).map(r=>r.slice(5));
    if(!items.length) return [{id:"none", label:"（拾える物がない）"}];
    items.forEach(it=>t.push({id:`pick:${it}`, label:ITEMS[it]?.name ?? it, tag:"拾う"}));
    return t;
  }

  if(cmdId==="use"){
    if(S.inventory.length){
      S.inventory.forEach(it=>t.push({id:`it:${it}`, label:ITEMS[it]?.name ?? it, tag:"所持"}));
    }
    if(S.location==="dock"){
      t.push({id:"use:gate", label:"封鎖ゲートに使う", tag:"解除"});
      t.push({id:"use:ship", label:"輸送船を動かす", tag:"脱出"});
    }
    if(S.location==="radio") t.push({id:"use:radio", label:"無線照合を進める", tag:"航路"});
    if(S.location==="workshop") t.push({id:"use:repair", label:"整備を進める", tag:"整備"});
    return t.length? t : [{id:"none", label:"（使えるものがない）"}];
  }

  if(cmdId==="hide"){
    return [
      {id:"hide:shadow", label:"物陰に隠れる", tag:"回避"},
      {id:"hide:still", label:"息を殺す", tag:"回避"},
    ];
  }

  if(cmdId==="run"){
    return [
      {id:"run:back", label:"引く", tag:"離脱"},
      {id:"run:cut", label:"迂回する", tag:"離脱"},
    ];
  }

  if(cmdId==="drop"){
    if(!S.inventory.length) return [{id:"none", label:"（捨てる物がない）"}];
    return S.inventory.map(it=>({id:`drop:${it}`, label:`${ITEMS[it]?.name ?? it}を捨てる`, tag:"整理"}));
  }

  return [{id:"none", label:"（対象なし）"}];
}

/* =========================================================
   10) コマンド本体（runCommand）
   - ここは “分岐の交通整理”
   - 実処理は下の「コマンド処理セクション」へ分ける
========================================================= */
function runCommand(cmdId, targetId){
  targetUI.close();
  if(S.ended) return;

  S.turn++;

  // 警戒の基本増減（ざっくり）
  const baseAlert = {
    fight:+18, run:+10, hide:+4,
    touch:+2, pickup:+1, use:+2, order:+1,
    move:+0, examine:+0, talk:+0, apologize:-1, drop:+0
  }[cmdId] ?? 0;
  S.alert = clamp(S.alert + baseAlert);

  if(targetId==="none"){
    pushLog("うまくいかない。", "muted");
    return afterStep();
  }

  // 移動
  if(cmdId==="move" && targetId.startsWith("loc:")){
    const next=targetId.slice(4);
    pushLog(`移動… <span class="muted">${LOC[next].name}</span>`);
    enterLocation(next);
    return afterStep();
  }

  // 調べる / 触る / 拾う / 使う / 捨てる
  if(cmdId==="examine") { CmdExamine.handle(targetId); return afterStep(); }
  if(cmdId==="touch")   { CmdTouch.handle(targetId);   return afterStep(); }
  if(cmdId==="pickup" && targetId.startsWith("pick:")) { CmdPickup.handle(targetId.slice(5)); return afterStep(); }
  if(cmdId==="use")     { CmdUse.handle(targetId);     return afterStep(); }
  if(cmdId==="drop" && targetId.startsWith("drop:")) { CmdDrop.handle(targetId.slice(5)); return afterStep(); }

  // 会話：対象選択した瞬間に NPC台詞をログへ確定 → 返答だけポップアップ
  if(cmdId==="talk" && targetId.startsWith("ch:")){
    const id=targetId.slice(3);
    CmdTalk.begin(id);
    // 返答選択後に afterStep() を呼ぶ
    return dialogueUI.open(id, {noticed:true}, afterStep);
  }

  // 命令/隠れる/逃げる/闘う/謝る（必要なら会話に寄せる）
  if(cmdId==="order" && targetId.startsWith("ch:")){ CmdOrder.handle(targetId.slice(3)); return afterStep(); }
  if(cmdId==="hide"){ CmdHide.handle(targetId); return afterStep(); }

  if(cmdId==="run"){
    CmdRun.handle(targetId);
    return afterStep();
  }

  if(cmdId==="fight"){
    CmdFight.handle(targetId);
    return afterStep();
  }

  if(cmdId==="apologize" && targetId.startsWith("ch:")){
    // 謝るは「会話の一種」にしてもOK。いまは簡易に talk と同じ流れへ寄せる。
    const id=targetId.slice(3);
    CmdTalk.begin(id, {force:"apologize"});
    return dialogueUI.open(id, {noticed:true, force:"apologize"}, afterStep);
  }

  pushLog("うまくいかない。", "muted");
  return afterStep();
}

/* =========================================================
   11) コマンド処理セクション（各コマンドの中身）
   - ここを“深く”していくと味が出る
========================================================= */
const CmdExamine = {
  handle(targetId){
    if(targetId.startsWith("ch:")){
      const id=targetId.slice(3);
      const c=S.chars[id];
      c.met=true;
      pushLog(`${c.name}の様子を窺う。`, "muted");
      const obj = S.present.find(o=>o.id===id);
      if(obj && !obj.noticed){
        pushLog(`${c.name}はまだこちらに気づいていない。`, "muted");
        return;
      }
      if(S.suspect && chance(40)){
        pushLog(`${c.name}「提督…行動が多いです」`, "danger");
        S.alert = clamp(S.alert+6);
      }else{
        pushLog(`${c.name}は短く頷くだけだ。`, "muted");
      }
      return;
    }

    if(targetId.startsWith("obj:")){
      const obj=targetId.slice(4);
      examined(obj);
      pushLog(`調べる：<span class="muted">${obj}</span>`);

      // ---- ここから “場所別の派生” を増やす ----
      // 資材庫：戸棚→鍵
      if(S.location==="storage" && obj==="戸棚"){
        if(!S.flags.has("has_gate_key")){
          pushLog("鍵束の刻印。封鎖ゲートのものだ。", "ok");
          reveal("item:gate_key");
        }else pushLog("空だ。鍵は確保済み。", "muted");
        return;
      }

      // 資材庫：木箱→燃料缶（1回）
      if(S.location==="storage" && obj==="木箱"){
        if(!LS().depleted.has("fuel_box")){
          pushLog("木箱の底に、油の匂い。", "muted");
          reveal("item:fuel_can");
          depleted("fuel_box");
        }else pushLog("空箱ばかりだ。", "muted");
        return;
      }

      // 無線室：暗号表
      if(S.location==="radio" && obj==="暗号表の引き出し"){
        if(!hasItem("codebook") && !LS().depleted.has("codebook")){
          pushLog("紙束。暗号表だ。", "ok");
          reveal("item:codebook");
          depleted("codebook");
        }else pushLog("もう見当たらない。", "muted");
        return;
      }

      // 浴場：脱衣棚→布片、鍵チャンス
      if(S.location==="bath" && obj==="脱衣棚"){
        if(!LS().depleted.has("locker")){
          pushLog("タグ付きの布片。匂いを散らせる。", "ok");
          reveal("item:cloth_tag");
          if(!S.flags.has("has_gate_key") && chance(35)){
            pushLog("奥に小さな鍵束…封鎖の刻印。", "ok");
            reveal("item:gate_key");
          }else{
            pushLog("鍵の痕跡はあるが、確証は薄い。", "muted");
          }
          depleted("locker");
        }else pushLog("棚はもう荒らされている。", "muted");
        return;
      }

      // 工廠：部品片
      if(S.location==="workshop" && obj==="予備部材棚"){
        if(!LS().depleted.has("scrap")){
          pushLog("使えそうな部材。整備に回せる。", "ok");
          reveal("item:scrap");
          depleted("scrap");
        }else pushLog("役立つ部材はもうない。", "muted");
        return;
      }
      // ---- ここまで ----

      pushLog("手掛かりは少ない。", "muted");
      return;
    }

    if(targetId.startsWith("sub:")){
      const sub=targetId.slice(4);
      examined(sub);
      pushLog(`さらに調べる：<span class="muted">${sub}</span>`);
      pushLog("細部まで見ても、得るものは少ない。", "muted");
    }
  }
};

const CmdTouch = {
  handle(targetId){
    if(targetId.startsWith("ch:")){
      const id=targetId.slice(3);
      const c=S.chars[id];
      c.met=true;
      const obj=S.present.find(o=>o.id===id);
      if(obj && !obj.noticed){
        pushLog(`${c.name}に近づいた。相手はまだ気づいていない。`, "muted");
        if(chance(40)){
          obj.noticed=true;
          pushLog(`${c.name}がこちらを向いた。`, "danger");
          S.alert=clamp(S.alert+6);
        }
        return;
      }
      pushLog(`${c.name}に近づく。`, "muted");
      if(S.suspect && chance(35)){
        pushLog(`${c.name}「提督。距離が近い」`, "danger");
        S.alert=clamp(S.alert+6);
      }else{
        pushLog(`${c.name}は一瞬だけ迷う顔をした。`, "muted");
        c.trust=clamp(c.trust+1);
        c.intimacy=clamp(c.intimacy+2);
      }
      return;
    }

    if(targetId.startsWith("obj:")){
      const obj=targetId.slice(4);
      touched(obj);
      pushLog(`触る：<span class="muted">${obj}</span>`);

      if(S.location==="radio" && obj==="受信機"){
        if(!S.flags.has("contact_possible")){
          pushLog("ノイズの底に符丁。繋がる“窓”がある。", "ok");
          S.flags.add("contact_possible");
        }else{
          pushLog("受信状態を整える。照合へ進めそうだ。", "muted");
        }
        return;
      }

      if(S.location==="dock" && obj==="輸送船"){
        pushLog("輸送船に手を掛ける。ここから先は“出港”だ。", "muted");
        if(isSomeoneNoticed() && chance(35)){
          setSuspect("埠頭での不審行動");
          S.alert=clamp(S.alert+8);
        }
        return;
      }

      if(S.location==="dock" && obj==="封鎖ゲート"){
        pushLog("封鎖は堅い。鍵が要る。", "muted");
        if(isSomeoneNoticed() && chance(35)) setSuspect("封鎖ゲートに干渉");
        return;
      }

      if(isSomeoneNoticed() && chance(25)){
        setSuspect("装置に干渉する姿を見られた");
        S.alert=clamp(S.alert+6);
      }
      return;
    }

    if(targetId.startsWith("sub:")){
      pushLog("触れるが、意味は薄い。", "muted");
    }
  }
};

const CmdPickup = {
  handle(it){
    const st = LS();
    if(!st.revealed.has("item:"+it)){
      pushLog("まだ見つけていない。", "muted");
      return;
    }
    st.revealed.delete("item:"+it);

    if(it==="fuel_can"){
      pushLog("燃料缶を確保した。<span class='ok'>燃料+8</span>", "ok");
      S.fuel = Math.max(0, S.fuel + 8);
      return;
    }

    if(it==="gate_key"){
      pushLog("ゲート鍵を確保した。", "ok");
      S.flags.add("has_gate_key");
      addItem("gate_key");
      if(isSomeoneNoticed()) setSuspect("鍵の確保を見られた");
      else if(chance(15)) setSuspect("鍵の所在が動いた");
      return;
    }

    if(it==="codebook"){
      pushLog("暗号表を確保した。", "ok");
      addItem("codebook");
      return;
    }

    if(it==="scrap"){
      pushLog("部品片を確保した。", "ok");
      addItem("scrap");
      return;
    }

    if(it==="cloth_tag"){
      pushLog("タグ付き布片を確保した。", "ok");
      addItem("cloth_tag");
      return;
    }

    addItem(it);
  }
};

const CmdUse = {
  handle(targetId){
    if(targetId.startsWith("it:")){
      const it=targetId.slice(3);

      if(it==="scrap"){
        if(S.location==="workshop"){
          removeItem("scrap");
          S.flags.add("ship_repaired");
          pushLog("部品が噛み合う。機関の息が戻る。<span class='ok'>整備完了</span>", "ok");
        }else pushLog("工廠で使うべきだ。", "muted");
        return;
      }

      if(it==="codebook"){
        if(S.location==="radio" && S.flags.has("contact_possible")){
          S.flags.add("route_confirmed");
          pushLog("暗号表で照合。航路が確定する。<span class='ok'>航路確定</span>", "ok");
          if(isSomeoneNoticed()) setSuspect("無線照合を見られた");
          else if(chance(20)) setSuspect("無線の使用履歴");
        }else pushLog("無線室で照合すべきだ。", "muted");
        return;
      }

      if(it==="gate_key"){
        if(S.location==="dock"){ openGate(); }
        else pushLog("埠頭の封鎖ゲートで使うべきだ。", "muted");
        return;
      }

      if(it==="cloth_tag"){
        pushLog("布片の匂いを散らす。気配が薄まる。", "muted");
        S.alert = clamp(S.alert-6);
        return;
      }

      pushLog("使い道がない。", "muted");
      return;
    }

    if(targetId==="use:radio"){
      if(S.location!=="radio"){ pushLog("ここでは無線照合ができない。", "muted"); return; }
      if(!S.flags.has("contact_possible")){ pushLog("まず受信機を確かめる必要がある。", "muted"); return; }
      if(hasItem("codebook")){
        S.flags.add("route_confirmed");
        pushLog("照合が通る。<span class='ok'>航路確定</span>", "ok");
      }else{
        if(chance(30)){ S.flags.add("route_confirmed"); pushLog("不安定だが照合に成功。<span class='ok'>航路確定</span>", "ok"); }
        else pushLog("照合が足りない。暗号表が欲しい。", "muted");
      }
      if(isSomeoneNoticed()) setSuspect("無線照合を見られた");
      else if(chance(20)) setSuspect("無線の使用履歴");
      return;
    }

    if(targetId==="use:repair"){
      if(S.location!=="workshop"){ pushLog("ここでは整備ができない。", "muted"); return; }
      if(S.flags.has("ship_repaired")){ pushLog("整備は完了している。", "muted"); return; }
      if(hasItem("scrap")){
        removeItem("scrap");
        S.flags.add("ship_repaired");
        pushLog("整備が通る。<span class='ok'>整備完了</span>", "ok");
      }else pushLog("部品が足りない。部品片が必要だ。", "muted");
      return;
    }

    if(targetId==="use:gate"){ if(S.location!=="dock"){ pushLog("ここでは封鎖ゲートがない。", "muted"); return; } openGate(); return; }
    if(targetId==="use:ship"){ if(S.location!=="dock"){ pushLog("ここでは出港できない。", "muted"); return; } tryEscape(); return; }

    pushLog("使えない。", "muted");
  }
};

const CmdDrop = {
  handle(it){
    removeItem(it);
    pushLog(`（破棄：${ITEMS[it]?.name ?? it}）`, "muted");
  }
};

const CmdTalk = {
  // 対象を選んだ瞬間に「NPC台詞をログへ確定」
  begin(id, ctx={}){
    const obj = S.present.find(o=>o.id===id);
    if(obj) obj.noticed = true; // 話しかけた＝気づき確定
    S.chars[id].met = true;

    const npc = Dialogue.npcLine(id, {noticed:true, ...ctx});
    pushLog(`<b>${S.chars[id].name}</b>：${stripHtml(npc)}`);
  }
};

const CmdOrder = {
  handle(id){
    const c=S.chars[id];
    c.met=true;

    pushLog(`${c.name}に命令する。`, "muted");

    const p = clamp(10 + (c.trust-40), 5, 80);
    if(chance(p)){
      if(!S.party.includes(id)){
        pushLog(`${c.name}「了解。…ただし、提督」`, "muted");
        pushLog(`${c.name}「変なことをするなら止めます」`, S.suspect?"danger":"muted");
        S.party.push(id);
        S.present = S.present.filter(o=>o.id!==id);
        c.trust=clamp(c.trust+1);
      }else{
        pushLog(`${c.name}「了解」`, "muted");
        c.trust=clamp(c.trust+1);
      }
    }else{
      pushLog(`${c.name}は頷かない。`, "danger");
      c.trust=clamp(c.trust-3);
      if(S.suspect && chance(25)) S.alert=clamp(S.alert+6);
    }
  }
};

const CmdHide = {
  handle(kind){
    pushLog("身を潜める。", "muted");
    const seen = isSomeoneNoticed();
    if(seen && chance(40)) setSuspect("隠れ方が不自然");

    const p = clamp(55 - Math.floor(S.alert/3) + (kind==="hide:still"?10:0), 10, 75);
    if(seen && chance(p)){
      pushLog("視線が逸れた。気配が薄まる。", "ok");
      S.present.forEach(o=>o.noticed=false);
      S.alert = clamp(S.alert-10);
    }else{
      S.alert = clamp(S.alert-6);
      pushLog("息を止める。だが心臓の音がうるさい。", "muted");
    }
  }
};

const CmdRun = {
  handle(){
    pushLog("距離を取る。背中に視線が刺さる。", "muted");
    setSuspect("露骨な離脱行動");
    S.alert = clamp(S.alert + 6);
  }
};

const CmdFight = {
  handle(){
    setSuspect("交戦");
    pushLog("短い衝突。勝っても、音は残る。", "danger");
    if(chance(55)){
      pushLog("押し返した。だが目は増える。", "muted");
      S.alert = clamp(S.alert+10);
    }else{
      pushLog("押される。腕を取られそうになる。", "danger");
      if(chance(35)) S.flags.add("captured");
    }
  }
};

/* =========================================================
   12) 脱出フロー（ゲート解除/出港）
========================================================= */
function openGate(){
  if(S.flags.has("gate_opened")){ pushLog("封鎖は既に解除されている。", "muted"); return; }
  if(S.flags.has("has_gate_key") || hasItem("gate_key")){
    S.flags.add("gate_opened");
    pushLog("封鎖ゲートが外れた。道が一本通る。<span class='ok'>封鎖解除</span>", "ok");
    setSuspect("封鎖解除は脱走準備に見える");
    S.alert = clamp(S.alert+8);
  }else{
    pushLog("鍵がない。資材庫か浴場を探れ。", "muted");
  }
}

function tryEscape(){
  const need = ["route_confirmed","ship_repaired","gate_opened"];
  const miss = need.filter(f=>!S.flags.has(f));
  if(miss.length){
    pushLog("出港条件が揃っていない。", "muted");
    pushLog(`不足：<span class="danger">${miss.join(", ")}</span>`, "danger");
    return;
  }
  if(S.fuel < 30){
    pushLog("燃料が足りない。", "muted");
    return;
  }
  setSuspect("出港を試みた");
  S.flags.add("escaped_mainland");
  pushLog("出港する。波を割り、島影が遠ざかる。", "ok");
}

/* =========================================================
   13) 疑い時の“制止→捕縛”チェック（理不尽にならない条件）
   - suspect なしなら絶対に捕縛しない
========================================================= */
function captureCheck(){
  if(!S.suspect) return;

  const noticed = S.present.filter(o=>o.noticed);
  if(!noticed.length) return;

  const p = clamp(8 + Math.floor(S.alert/8), 6, 30);
  if(!chance(p)) return;

  const o = noticed[rint(noticed.length)];
  const name = CHAR[o.id].name;

  pushLog(`${name}が前に出る。<span class="danger">「提督、止まって」</span>`, "danger");
  S.alert = clamp(S.alert + 8);

  if(S.alert>=100){
    S.flags.add("captured");
  }
}

function pressureCheck(){
  if(S.turn > 70 && chance(12)){
    pushLog("巡回が濃くなる。", "muted");
    S.alert = clamp(S.alert+4);
  }
  if(S.alert>=100){
    S.flags.add("captured");
  }
}

/* =========================================================
   14) エンディング判定
========================================================= */
function resolveEnding(){
  const escaped = S.flags.has("escaped_mainland");
  const captured = S.flags.has("captured");
  const neverSuspected = !S.suspect;

  const [b,all]=bondedCount();
  const allBonded = (all>0 && b===all);

  if(allBonded && (escaped || captured)) return "king";
  if(b>=5 && (escaped || captured)) return "harem";
  if(escaped && neverSuspected) return "dream";
  if(escaped) return "normal";
  if(captured) return "bad";
  return null;
}
function endGame(id){
  S.ended=true;
  S.ending=id;
  sep();
  pushLog(`<b>${END[id]}</b>`, id==="bad" ? "danger":"ok");
  pushLog(`<span class="muted small">MENU → 最初から / ロード で再開できます。</span>`, "muted");
}

/* =========================================================
   15) ターン後処理（出現更新 / 捕縛チェック / エンド）
========================================================= */
function afterStep(){
  // 出現入れ替え（頻度は低め）
  if(chance(18)) refreshPresent(true);

  captureCheck();
  pressureCheck();

  const e = resolveEnding();
  if(e) endGame(e);

  renderTop();
}

/* =========================================================
   16) セーブ/ロード（localStorage）
========================================================= */
function resetLogFromState(){
  el.log.innerHTML="";
  S.log.forEach(e=>{
    const div=document.createElement("div");
    if(e.cls) div.className=e.cls;
    div.innerHTML=e.line;
    el.log.appendChild(div);
  });
  el.log.scrollTop = el.log.scrollHeight + 9999;
}
function serialize(){
  return {
    seed:S.seed, turn:S.turn, alert:S.alert, fuel:S.fuel, suspect:S.suspect,
    inventory:[...S.inventory], invLimit:S.invLimit,
    location:S.location, present:[...S.present], party:[...S.party],
    flags:[...S.flags],
    chars:S.chars,
    locState:Object.fromEntries(Object.keys(S.locState).map(k=>[
      k,
      {
        examined:[...S.locState[k].examined],
        touched:[...S.locState[k].touched],
        revealed:[...S.locState[k].revealed],
        depleted:[...S.locState[k].depleted],
     dlg:{
  shigure:{
    thread:S.dlg.shigure.thread,
    stage:S.dlg.shigure.stage,
    lastTurn:S.dlg.shigure.lastTurn,
    metCount:S.dlg.shigure.metCount,
    topics:[...S.dlg.shigure.topics],
  }
},
 }
    ])),
    log:S.log,
    ended:S.ended, ending:S.ending
  };
}
function hydrate(obj){
  seed = obj.seed ?? seed;
  rnd = mulberry32(seed);

  S = defaultState();
  S.seed=seed;
  S.turn=obj.turn??0;
  S.alert=obj.alert??10;
  S.fuel=obj.fuel??25;
  S.suspect=!!obj.suspect;
  S.inventory=obj.inventory??[];
  S.invLimit=obj.invLimit??8;
  S.location=obj.location??"hq";
  S.present=obj.present??[];
  S.party=obj.party??[];
  S.flags=new Set(obj.flags??[]);
  S.chars=obj.chars??S.chars;

  if(obj.locState){
    Object.keys(obj.locState).forEach(k=>{
      const v=obj.locState[k];
      if(!S.locState[k]) return;
      S.locState[k].examined = new Set(v.examined||[]);
      S.locState[k].touched  = new Set(v.touched||[]);
      S.locState[k].revealed = new Set(v.revealed||[]);
      S.locState[k].depleted = new Set(v.depleted||[]);
    });
 if(obj.dlg && obj.dlg.shigure){
  S.dlg = S.dlg || {};
  S.dlg.shigure = {
    thread: obj.dlg.shigure.thread ?? null,
    stage: obj.dlg.shigure.stage ?? 0,
    lastTurn: obj.dlg.shigure.lastTurn ?? 0,
    metCount: obj.dlg.shigure.metCount ?? 0,
    topics: new Set(obj.dlg.shigure.topics ?? []),
  };
}
 }
  S.log=obj.log??[];
  S.ended=!!obj.ended;
  S.ending=obj.ending??null;

  resetLogFromState();
  renderTop();
}
function saveLocal(){
  localStorage.setItem("island_escape_save", JSON.stringify(serialize()));
  toast("セーブしました");
}
function loadLocal(){
  const raw = localStorage.getItem("island_escape_save");
  if(!raw){ toast("セーブがありません"); return; }
  hydrate(JSON.parse(raw));
  toast("ロードしました");
}

/* =========================================================
   17) MENU / 起動
========================================================= */
function newGame(keepSeed=false){
  if(!keepSeed){
    seed = (Date.now()>>>0) ^ 0xC0FFEE;
  }
  rnd = mulberry32(seed);
  S = defaultState();
  S.seed = seed;

  pushLog("—— <b>離島鎮守府</b> ——");
  pushLog("夜の潮が重い。ここを抜け、本土へ辿り着け。<br><span class='muted'>（航路/鍵/整備/封鎖解除 → 埠頭で出港）</span>");
  enterLocation("hq");
  renderTop();
}

function buildCmdButtons(){
  el.cmdGrid.innerHTML = CMD.map(c=>`<button data-c="${c.id}">${c.label}</button>`).join("");
  el.cmdGrid.querySelectorAll("button").forEach(b=>{
    b.onclick=()=>targetUI.open(b.dataset.c);
  });
}

/* =========================================================
   18) 会話セクション（ここだけ集中して作り込める）
   - npcLine(): 相手の第一声
   - options(): 返答選択肢
   - applyChoice(): 選択肢の効果
========================================================= */
const Dialogue = (() => {

  function npcLine(id, context){
   if(id==="shigure") return ShigureDialogue.npcLine(context);
 const suspect = S.suspect;
    const noticed = context.noticed;

    const base = {
      shigure: suspect ? "時雨「……提督。行き先を、聞いていい？」" : (noticed?"時雨「提督。夜更かし？」":"時雨「……誰かいるの？」"),
      asashio: suspect ? "朝潮「提督。行動理由を確認します」" : (noticed?"朝潮「提督。こんな時間に？」":"朝潮「……気配が…」"),
      kasumi: suspect ? "霞「はぁ？また逃げる気？」" : (noticed?"霞「今夜は落ち着きないわね」":"霞「……誰かいるの？」"),
      takao: suspect ? "高雄「提督。動きが不自然です。説明を」" : (noticed?"高雄「提督。お疲れですか」":"高雄「……そこですか？」"),
      kongo: suspect ? "金剛「提督！Stop！どこ行くのネ！」" : (noticed?"金剛「Hey提督！眠れない？」":"金剛「誰かいるヨ！」"),
      hatsuzuki: suspect ? "初月「提督。目的を言え」" : (noticed?"初月「提督。行動が多い」":"初月「……誰だ」"),
      urakaze: suspect ? "浦風「提督…無茶したらいけんよ」" : (noticed?"浦風「提督、寒うない？」":"浦風「…提督？」"),
      ikazuchi: suspect ? "雷「提督！待って！どこ行くの！？」" : (noticed?"雷「提督、どうしたの？」":"雷「えっ、誰？」"),
      hibiki: suspect ? "響「……止まれ」" : (noticed?"響「……夜だ」":"響「……気配」"),
    }[id];
/* =========================
   Shigure Dialogue Section
   - 時雨専用の会話生成（連続会話 / 話題解禁）
========================= */
const ShigureDialogue = (() => {

  function D(){ return S.dlg.shigure; }

  function ctxBase(context){
    const noticed = !!context.noticed;
    const inParty = S.party.includes("shigure");
    const loc = S.location;
    const alert = S.alert;
    const suspect = S.suspect;
    const has = (f)=>S.flags.has(f);
    const hasItem_ = (it)=>hasItem(it);
    const met = S.chars.shigure.met;
    const trust = S.chars.shigure.trust;
    const intimacy = S.chars.shigure.intimacy;

    // 状況タグ（会話分岐のキーにする）
    const tags = [];
    if(inParty) tags.push("party");
    if(suspect) tags.push("suspect");
    if(alert>=70) tags.push("high_alert");
    if(loc==="dock") tags.push("dock");
    if(loc==="radio") tags.push("radio");
    if(loc==="workshop") tags.push("workshop");
    if(loc==="tunnel") tags.push("tunnel");
    if(!noticed) tags.push("unnoticed");
    if(trust>=75) tags.push("high_trust");
    if(intimacy>=40) tags.push("close");
    if(has("route_confirmed")) tags.push("route_ok");
    if(has("ship_repaired")) tags.push("repair_ok");
    if(has("gate_opened")) tags.push("gate_ok");
    if(S.flags.has("escaped_mainland")) tags.push("escaped");

    return { noticed,inParty,loc,alert,suspect,met,trust,intimacy,tags };
  }

  function pick(arr){ return arr[rint(arr.length)]; }

  // 連続会話の管理：スレッド進行/終了
  function startThread(id){
    D().thread = id;
    D().stage = 0;
  }
  function nextStage(){
    D().stage += 1;
  }
  function endThread(){
    D().thread = null;
    D().stage = 0;
  }
  function touchTopic(t){
    D().topics.add(t);
  }
  function hasTopic(t){
    return D().topics.has(t);
  }

  function npcLine(context){
    const c = ctxBase(context);

    // 会話回数カウント（“時雨は記憶してる感”を出す）
    D().metCount = (D().metCount||0) + 1;
    D().lastTurn = S.turn;

    // 連続会話が進行中ならそれを優先
    if(D().thread){
      return npcLineThread(c);
    }

    // 触れてないのにいきなり捕縛ムーブ、を防ぐ：
    // suspect が無いなら “止めに来る台詞” は出さない
    if(!c.suspect){
      return npcLineNormal(c);
    }
    return npcLineSuspect(c);
  }

  function npcLineNormal(c){
    // “時雨らしい”静かな入口：状況を一言、提督を責めない
    if(c.loc==="dock"){
      return pick([
        "時雨「……埠頭。夜の波は、音が大きいね」",
        "時雨「ここは目立つ。風のせいにできない足音が出る」",
        "時雨「提督、ここは…見張りが来る」",
      ]);
    }
    if(c.loc==="radio"){
      return pick([
        "時雨「無線室…？　珍しいね」",
        "時雨「…音、聞いてる？」",
        "時雨「灯りが落ち着かない。…僕も同じかな」",
      ]);
    }
    if(c.loc==="workshop"){
      return pick([
        "時雨「工廠。油の匂いがする」",
        "時雨「整備？　…提督の手、汚れるよ」",
        "時雨「工具の音って、夜だと余計に響く」",
      ]);
    }

    // “未察知→気づいた”の時に一段階あると良い
    if(c.tags.includes("unnoticed")){
      return pick([
        "時雨「……誰かいるの？」",
        "時雨「……音がした」",
        "時雨「……提督？」",
      ]);
    }

    // 通常
    if(c.tags.includes("high_trust")){
      return pick([
        "時雨「提督。…顔、硬い。大丈夫？」",
        "時雨「無理してない？　…君は、ひとりで抱えがちだ」",
        "時雨「…今夜は、何を探してるの？」",
      ]);
    }
    return pick([
      "時雨「提督。夜更かし？」",
      "時雨「…こんな時間に動くと、空気が変わる」",
      "時雨「提督。…落ち着いてるようで、焦ってる」",
    ]);
  }

  function npcLineSuspect(c){
    // suspect が立ってる時：断定しないが“止める”方向へ寄せる
    if(c.loc==="dock"){
      // 埠頭で疑い＋時雨：かなり強めに止める（でも静か）
      startThread("dock_stop");
      return "時雨「……提督。そこは、行き止まりじゃない。…でも“帰り道”にもならない」";
    }
    if(c.loc==="radio"){
      startThread("radio_probe");
      return "時雨「無線。…誰に繋ぐつもり？」";
    }
    if(c.loc==="workshop"){
      startThread("workshop_probe");
      return "時雨「整備の音は残る。…君の“予定”も残るよ」";
    }

    // 一般疑い
    startThread("suspect_probe");
    return pick([
      "時雨「……提督。行き先を、聞いていい？」",
      "時雨「提督。今夜の動き…少しだけ、説明して」",
      "時雨「…僕は、見ないふりが得意じゃない」",
    ]);
  }

  function npcLineThread(c){
    const th = D().thread;
    const st = D().stage;

    // --- 疑い：探り ---
    if(th==="suspect_probe"){
      if(st===0) return "時雨「…“見回り”って言うなら、どこを？」";
      if(st===1) return "時雨「君が何かを隠してるなら、僕は止める。…優しさで」";
      return "時雨「提督。…次の一歩で、君の未来が変わる」";
    }

    // --- 無線室で疑い ---
    if(th==="radio_probe"){
      if(st===0) return "時雨「記録は残る。…残るのは、電波じゃなくて“理由”だよ」";
      if(st===1) return "時雨「照合？　それとも、確認？」";
      return "時雨「…本当に必要なら、僕は手伝う。だけど、嘘は嫌だ」";
    }

    // --- 工廠で疑い ---
    if(th==="workshop_probe"){
      if(st===0) return "時雨「整備は大事。でも、いまの君の手つきは…整備じゃない」";
      if(st===1) return "時雨「提督。…急ぐほど、音が出る」";
      return "時雨「…僕は君の味方だよ。だから、止める時は止める」";
    }

    // --- 埠頭で疑い：強めに止める ---
    if(th==="dock_stop"){
      if(st===0) return "時雨「船に触れたら、もう戻れない。…気持ちの話」";
      if(st===1) return "時雨「君が逃げたいのは、島じゃない。…多分」";
      return "時雨「…提督。僕の前でだけ、正直になって」";
    }

    return "時雨「……」";
  }

  function options(context){
    const c = ctxBase(context);
    const opts = [];

    // 連続会話スレッド中は、その段階の選択肢を返す
    if(D().thread){
      return optionsThread(c);
    }

    // 通常会話（疑い無し）
    if(!c.suspect){
      opts.push({key:"patrol", label:"「見回りだ。すぐ戻る」", tag:"無難"});
      opts.push({key:"smalltalk", label:"「眠れなくてな」", tag:"弱音"});
      opts.push({key:"ask", label:"「時雨はどうした？」", tag:"振る"});
      if(c.tags.includes("radio") && !S.flags.has("route_confirmed"))
        opts.push({key:"radio_hint", label:"「無線…少し確認したい」", tag:"目的"});
      if(c.tags.includes("dock"))
        opts.push({key:"dock_check", label:"「埠頭の様子を見ただけだ」", tag:"確認"});
      if(c.trust>=70 && !S.party.includes("shigure"))
        opts.push({key:"invite", label:"「一緒に来てくれ」", tag:"同行"});
      if(c.intimacy>=35)
        opts.push({key:"thanks", label:"「心配してくれて助かる」", tag:"距離"});
      opts.push({key:"end", label:"「戻るよ」", tag:"終了"});
      return opts;
    }

    // 疑いあり（基本）
    opts.push({key:"deny_soft", label:"「誤解だ。落ち着け」", tag:"否定"});
    opts.push({key:"explain", label:"「理由がある。聞くか？」", tag:"説明"});
    opts.push({key:"backoff", label:"「悪かった。戻る」", tag:"退く"});
    opts.push({key:"apologize", label:"「疑わせたならすまない」", tag:"謝る"});
    if(c.tags.includes("dock")) opts.push({key:"dock_back", label:"「ここは危ない。戻る」", tag:"退避"});
    return opts;
  }

  function optionsThread(c){
    const th = D().thread;
    const st = D().stage;

    // スレッドごとに “返答の幅” を作る：無難/正直/嘘/引く
    if(th==="suspect_probe"){
      if(st===0){
        return [
          {key:"t0_patrol", label:"「見回り。ルート確認だけ」", tag:"無難"},
          {key:"t0_honest", label:"「…戻りたい気分だった」", tag:"正直"},
          {key:"t0_lie", label:"「ただの散歩だ」", tag:"誤魔化す"},
          {key:"t0_end", label:"「やめよう。戻る」", tag:"退く"},
        ];
      }
      if(st===1){
        return [
          {key:"t1_explain", label:"「不安なんだ。…だから確認してる」", tag:"説明"},
          {key:"t1_apol", label:"「疑わせた。すまない」", tag:"謝る"},
          {key:"t1_push", label:"「止めるなら止めろ」", tag:"強硬"},
          {key:"t1_end", label:"「戻る」", tag:"退く"},
        ];
      }
      return [
        {key:"t2_trust", label:"「時雨を信じる。手伝ってくれ」", tag:"協力"},
        {key:"t2_back", label:"「…分かった。やめる」", tag:"撤退"},
      ];
    }

    if(th==="radio_probe"){
      if(st===0){
        return [
          {key:"r0_truth", label:"「航路を確かめるだけだ」", tag:"目的"},
          {key:"r0_hide", label:"「何でもない」", tag:"隠す"},
          {key:"r0_back", label:"「やめる」", tag:"退く"},
        ];
      }
      if(st===1){
        return [
          {key:"r1_use", label:"「照合を進める」", tag:"実行"},
          {key:"r1_stop", label:"「今日はやめる」", tag:"中断"},
          {key:"r1_ask", label:"「時雨はどう思う？」", tag:"相談"},
        ];
      }
      return [
        {key:"r2_partner", label:"「一緒に見てくれ」", tag:"協力"},
        {key:"r2_back", label:"「…戻る」", tag:"退く"},
      ];
    }

    if(th==="workshop_probe"){
      if(st===0){
        return [
          {key:"w0_repair", label:"「整備が必要だ」", tag:"目的"},
          {key:"w0_back", label:"「戻る」", tag:"退く"},
          {key:"w0_lie", label:"「点検だ」", tag:"誤魔化す"},
        ];
      }
      if(st===1){
        return [
          {key:"w1_use", label:"「部品を合わせる」", tag:"実行"},
          {key:"w1_stop", label:"「今はやめる」", tag:"中断"},
          {key:"w1_soft", label:"「…心配か？」", tag:"距離"},
        ];
      }
      return [
        {key:"w2_trust", label:"「手伝ってくれ」", tag:"協力"},
        {key:"w2_back", label:"「…やめる」", tag:"撤退"},
      ];
    }

    if(th==="dock_stop"){
      if(st===0){
        return [
          {key:"d0_back", label:"「戻る。触らない」", tag:"撤退"},
          {key:"d0_truth", label:"「…帰りたい。だけど理由はある」", tag:"正直"},
          {key:"d0_push", label:"「止めるなら、力づくで？」", tag:"強硬"},
        ];
      }
      if(st===1){
        return [
          {key:"d1_explain", label:"「本土に着けば終わる。だから…」", tag:"説明"},
          {key:"d1_apol", label:"「すまない。混乱してる」", tag:"謝る"},
          {key:"d1_back", label:"「戻る」", tag:"撤退"},
        ];
      }
      return [
        {key:"d2_help", label:"「時雨、手を貸してくれ」", tag:"協力"},
        {key:"d2_back", label:"「…やめる」", tag:"撤退"},
      ];
    }

    return [{key:"end", label:"「戻る」"}];
  }

  function applyChoice(context, key){
    const c = S.chars.shigure;
    const say = (txt)=>pushLog(`<span class="muted">提督</span>：「${txt}」`);

    // --- ユーティリティ：信頼/親密/警戒の動かし方（時雨だけ少し繊細）
    const trust = (v)=>{ c.trust = clamp(c.trust+v); };
    const intimacy = (v)=>{ c.intimacy = clamp(c.intimacy+v); if(c.intimacy>=100 && !c.bonded){ c.bonded=true; pushLog("（時雨との関係が深くなった）","ok"); } };
    const calm = (v)=>{ S.alert = clamp(S.alert - v); };
    const heat = (v)=>{ S.alert = clamp(S.alert + v); };

    // --- 連続会話中 ---
    if(D().thread){
      return applyThread(context, key, say, trust, intimacy, calm, heat);
    }

    // --- 通常（疑い無し） ---
    if(key==="patrol"){
      say("見回りだ。すぐ戻る。");
      pushLog("時雨「……そっか。無理はしないで」","muted");
      trust(+2); intimacy(+1); calm(2);
      return;
    }
    if(key==="smalltalk"){
      say("眠れなくてな。");
      pushLog("時雨「眠れない夜は、あるよ。…君だけじゃない」","muted");
      trust(+1); intimacy(+3); calm(2);
      touchTopic("soft_night");
      return;
    }
    if(key==="ask"){
      say("時雨はどうした？");
      pushLog("時雨「…見回り。君が動く夜は、波が騒ぐから」","muted");
      trust(+2); intimacy(+2);
      return;
    }
    if(key==="radio_hint"){
      say("無線…少し確認したい。");
      pushLog("時雨「…理由は分かった。…でも、痕跡は残るよ」","muted");
      trust(+1); intimacy(+1);
      touchTopic("radio_hint");
      // 無線を使う意図で疑いに寄りやすい：ただし即 suspect は立てない
      if(chance(25)) heat(4);
      return;
    }
    if(key==="dock_check"){
      say("埠頭の様子を見ただけだ。");
      pushLog("時雨「…見ただけ、ね。…なら、触らないで」","muted");
      trust(+1);
      if(chance(20)) heat(4);
      touchTopic("dock_warning");
      return;
    }
    if(key==="invite"){
      say("一緒に来てくれ。");
      const p = clamp(35 + (c.trust-60) + Math.floor(c.intimacy/10), 10, 85);
      if(chance(p)){
        pushLog("時雨「…分かった。目立たない距離で」","ok");
        if(!S.party.includes("shigure")) S.party.push("shigure");
        S.present = S.present.filter(o=>o.id!=="shigure");
        trust(+2); intimacy(+2);
      }else{
        pushLog("時雨「今は…君の“癖”を見ていたい」","muted");
        trust(-1);
      }
      return;
    }
    if(key==="thanks"){
      say("心配してくれて助かる。");
      pushLog("時雨「…言葉にされると、困る。…でも、嬉しい」","ok");
      trust(+2); intimacy(+6); calm(3);
      return;
    }
    if(key==="end"){
      say("戻るよ。");
      pushLog("時雨「…うん。足元、気をつけて」","muted");
      calm(2); trust(+1);
      return;
    }

    // --- 疑いあり（スレッド開始前は npcLine 側で startThread してる想定） ---
    if(key==="deny_soft"){
      say("誤解だ。落ち着け。");
      pushLog("時雨「誤解なら、説明できる。…できるよね」","danger");
      trust(-1); heat(4);
      startThread("suspect_probe"); // 安全に繋ぐ
      nextStage();
      return;
    }
    if(key==="explain"){
      say("理由がある。聞くか？");
      pushLog("時雨「…聞く。短く、正直に」","muted");
      startThread("suspect_probe");
      nextStage();
      trust(+1);
      return;
    }
    if(key==="backoff"){
      say("悪かった。戻る。");
      pushLog("時雨「…それがいい。今夜は、やめよう」","muted");
      calm(4); trust(+1);
      return;
    }
    if(key==="apologize"){
      say("疑わせたならすまない。");
      pushLog("時雨「…謝罪は受け取る。…でも、行動も変えて」","muted");
      trust(+2); calm(4);
      return;
    }
    if(key==="dock_back"){
      say("ここは危ない。戻る。");
      pushLog("時雨「…うん。埠頭は、答えが出てから」","muted");
      calm(5); trust(+1);
      return;
    }
  }

  function applyThread(context, key, say, trust, intimacy, calm, heat){
    const th = D().thread;
    const st = D().stage;

    // 便利：強硬は suspect を濃くして捕縛チェックが走りやすくなる
    const harden = ()=>{ setSuspect("時雨との対話で強硬姿勢"); heat(8); };

    if(th==="suspect_probe"){
      if(st===0){
        if(key==="t0_patrol"){
          say("見回り。ルート確認だけ。");
          pushLog("時雨「…ルート。…どこへ？」","muted");
          trust(+1); heat(2);
          nextStage();
          return;
        }
        if(key==="t0_honest"){
          say("…戻りたい気分だった。");
          pushLog("時雨「…うん。そういう夜はある。…でも“戻り方”を選んで」","muted");
          trust(+2); intimacy(+3); calm(2);
          nextStage();
          return;
        }
        if(key==="t0_lie"){
          say("ただの散歩だ。");
          if(chance(55)){
            pushLog("時雨「…嘘は、息の音が変わる」","danger");
            trust(-3); heat(8);
            nextStage();
          }else{
            pushLog("時雨「…散歩。なら、僕も歩く」","muted");
            trust(+1);
            // 同行させる圧
            if(!S.party.includes("shigure") && chance(40)){
              S.party.push("shigure");
              S.present = S.present.filter(o=>o.id!=="shigure");
              pushLog("時雨は黙って距離を合わせた。","muted");
            }
            nextStage();
          }
          return;
        }
        if(key==="t0_end"){
          say("やめよう。戻る。");
          pushLog("時雨「…うん。今夜は、それでいい」","ok");
          calm(6); trust(+1);
          endThread();
          return;
        }
      }
      if(st===1){
        if(key==="t1_explain"){
          say("不安なんだ。…だから確認してる。");
          pushLog("時雨「不安は悪くない。…でも、独りで抱えるのは悪い」","muted");
          trust(+3); intimacy(+4); calm(4);
          nextStage();
          return;
        }
        if(key==="t1_apol"){
          say("疑わせた。すまない。");
          pushLog("時雨「…いい。…君が戻るなら」","muted");
          trust(+3); calm(5);
          nextStage();
          return;
        }
        if(key==="t1_push"){
          say("止めるなら止めろ。");
          pushLog("時雨「……うん。止める」","danger");
          trust(-4); harden();
          // 捕縛へ寄せたいなら、ここで flagged captured を入れてもいいが、まずは圧だけ
          nextStage();
          return;
        }
        if(key==="t1_end"){
          say("戻る。");
          pushLog("時雨「…分かった。…ありがとう」","muted");
          calm(6); trust(+2);
          endThread();
          return;
        }
      }
      // st>=2
      if(key==="t2_trust"){
        say("時雨を信じる。手伝ってくれ。");
        pushLog("時雨「…うん。僕は君の味方だ。…だから、間違える前に止める」","ok");
        trust(+4); intimacy(+5); calm(6);
        touchTopic("shigure_partner");
        // 同行へ
        if(!S.party.includes("shigure")){
          S.party.push("shigure");
          S.present = S.present.filter(o=>o.id!=="shigure");
        }
        endThread();
        return;
      }
      if(key==="t2_back"){
        say("…分かった。やめる。");
        pushLog("時雨「…それでいい。今夜は、休もう」","ok");
        calm(8); trust(+2);
        endThread();
        return;
      }
    }

    if(th==="radio_probe"){
      if(st===0){
        if(key==="r0_truth"){
          say("航路を確かめるだけだ。");
          pushLog("時雨「…“だけ”って言い方は、好きじゃない。でも、理由は分かった」","muted");
          trust(+2); calm(2);
          touchTopic("radio_intent");
          nextStage();
          return;
        }
        if(key==="r0_hide"){
          say("何でもない。");
          pushLog("時雨「…何でもないなら、ここに居ない」","danger");
          trust(-2); heat(6);
          nextStage();
          return;
        }
        if(key==="r0_back"){
          say("やめる。");
          pushLog("時雨「…うん。それがいい」","ok");
          calm(6); trust(+1);
          endThread();
          return;
        }
      }
      if(st===1){
        if(key==="r1_use"){
          say("照合を進める。");
          pushLog("時雨「…僕が見る。君は、手を止めて」","muted");
          // ここで実際に route_confirmed を進める導線
          touchTopic("radio_help");
          trust(+2); intimacy(+2);
          // 実処理は CmdUse 側にあるから「やるなら使うコマンドへ」誘導
          pushLog("<span class='muted'>（ヒント：使う → 無線照合 を選ぶと進行しやすい）</span>","muted");
          nextStage();
          return;
        }
        if(key==="r1_stop"){
          say("今日はやめる。");
          pushLog("時雨「…賢い。夜は判断が荒れる」","ok");
          calm(8); trust(+2);
          endThread();
          return;
        }
        if(key==="r1_ask"){
          say("時雨はどう思う？");
          pushLog("時雨「…必要ならやる。でも、“逃げたい”なら止める」","muted");
          trust(+2); intimacy(+2);
          nextStage();
          return;
        }
      }
      // st>=2
      if(key==="r2_partner"){
        say("一緒に見てくれ。");
        pushLog("時雨「…うん。…君の手が震えないように」","ok");
        trust(+4); intimacy(+5); calm(6);
        if(!S.party.includes("shigure")){
          S.party.push("shigure");
          S.present = S.present.filter(o=>o.id!=="shigure");
        }
        endThread();
        return;
      }
      if(key==="r2_back"){
        say("…戻る。");
        pushLog("時雨「…うん。背中は僕が見る」","muted");
        calm(6); trust(+2);
        endThread();
        return;
      }
    }

    if(th==="workshop_probe"){
      if(st===0){
        if(key==="w0_repair"){
          say("整備が必要だ。");
          pushLog("時雨「…必要なのは分かった。…でも急ぐな」","muted");
          trust(+2); calm(2);
          touchTopic("repair_intent");
          nextStage();
          return;
        }
        if(key==="w0_back"){
          say("戻る。");
          pushLog("時雨「…うん。工具は嘘をつかない。焦りも」","muted");
          calm(6); trust(+1);
          endThread();
          return;
        }
        if(key==="w0_lie"){
          say("点検だ。");
          if(chance(50)){
            pushLog("時雨「…点検の手つきじゃない」","danger");
            trust(-2); heat(6);
          }else{
            pushLog("時雨「…そう。なら、短く」","muted");
            trust(+1);
          }
          nextStage();
          return;
        }
      }
      if(st===1){
        if(key==="w1_use"){
          say("部品を合わせる。");
          pushLog("時雨「…僕が灯りを持つ。手元が狂うと危ない」","muted");
          trust(+2); intimacy(+2);
          pushLog("<span class='muted'>（ヒント：使う → 整備 を選ぶと進行しやすい）</span>","muted");
          nextStage();
          return;
        }
        if(key==="w1_stop"){
          say("今はやめる。");
          pushLog("時雨「…うん。正しい判断」","ok");
          calm(8); trust(+2);
          endThread();
          return;
        }
        if(key==="w1_soft"){
          say("…心配か？");
          pushLog("時雨「心配してる。…君は、壊れ方が静かだから」","muted");
          trust(+2); intimacy(+5); calm(4);
          nextStage();
          return;
        }
      }
      // st>=2
      if(key==="w2_trust"){
        say("手伝ってくれ。");
        pushLog("時雨「…うん。君が間違えないように、横にいる」","ok");
        trust(+4); intimacy(+4); calm(6);
        if(!S.party.includes("shigure")){
          S.party.push("shigure");
          S.present = S.present.filter(o=>o.id!=="shigure");
        }
        endThread();
        return;
      }
      if(key==="w2_back"){
        say("…やめる。");
        pushLog("時雨「…それでいい。今日の君は、少し危うい」","muted");
        calm(8); trust(+2);
        endThread();
        return;
      }
    }

    if(th==="dock_stop"){
      if(st===0){
        if(key==="d0_back"){
          say("戻る。触らない。");
          pushLog("時雨「…うん。今夜の埠頭は、牙がある」","ok");
          calm(10); trust(+2);
          endThread();
          return;
        }
        if(key==="d0_truth"){
          say("…帰りたい。だけど理由はある。");
          pushLog("時雨「…うん。理由は、あとで聞く。今は、ここから離れよう」","muted");
          trust(+3); intimacy(+4); calm(6);
          nextStage();
          return;
        }
        if(key==="d0_push"){
          say("止めるなら、力づくで？");
          pushLog("時雨「……必要なら」","danger");
          trust(-4); harden();
          nextStage();
          return;
        }
      }
      if(st===1){
        if(key==="d1_explain"){
          say("本土に着けば終わる。だから…");
          pushLog("時雨「…“終わる”って言い方は嫌い。…でも、君の本音だ」","muted");
          trust(+3); intimacy(+3); heat(2);
          nextStage();
          return;
        }
        if(key==="d1_apol"){
          say("すまない。混乱してる。");
          pushLog("時雨「…謝るより、戻ろう。君の手が冷たい」","muted");
          trust(+3); intimacy(+4); calm(8);
          endThread();
          return;
        }
        if(key==="d1_back"){
          say("戻る。");
          pushLog("時雨「…うん。僕が先を歩く」","ok");
          calm(10); trust(+2);
          endThread();
          return;
        }
      }
      // st>=2
      if(key==="d2_help"){
        say("時雨、手を貸してくれ。");
        pushLog("時雨「…うん。君が壊れないように」","ok");
        trust(+5); intimacy(+6); calm(10);
        if(!S.party.includes("shigure")){
          S.party.push("shigure");
          S.present = S.present.filter(o=>o.id!=="shigure");
        }
        endThread();
        return;
      }
      if(key==="d2_back"){
        say("…やめる。");
        pushLog("時雨「…それでいい。今夜の勝ちは、“戻る”だ」","ok");
        calm(12); trust(+3);
        endThread();
        return;
      }
    }

    // フォールバック
    say("…戻る。");
    endThread();
  }

  return { npcLine, options, applyChoice };
})();

    return base;
  }

  function options(id, context){
   if(id==="shigure") return ShigureDialogue.options(context);
 const c=S.chars[id];
    const opts = [];

    // 謝るに寄せたい時（apologize コマンドなど）
    if(context.force==="apologize"){
      opts.push({key:"apologize", label:"「疑わせたならすまない」", tag:"謝る"});
      opts.push({key:"back", label:"「戻る」", tag:"退く"});
      return opts;
    }

    // 基本の会話
    opts.push({key:"neutral", label:"「ちょっと見回りだ」", tag:"無難"});
    opts.push({key:"lie", label:"「眠れなくて散歩してた」", tag:"誤魔化す"});
    opts.push({key:"back", label:"「悪い、戻る」", tag:"退く"});

    if(c.trust>=70 && !S.party.includes(id)){
      opts.push({key:"join", label:"「一緒に来てくれ」", tag:"同行"});
    }

    if(S.suspect){
      opts.push({key:"explain", label:"「誤解だ。理由がある」", tag:"説明"});
      opts.push({key:"apologize", label:"「疑わせたならすまない」", tag:"謝る"});
    }

    if(c.intimacy>=30){
      opts.push({key:"soft", label:"「心配してくれて助かる」", tag:"距離を詰める"});
    }

    return opts;
  }

  function applyChoice(id, context, key){
   if(id==="shigure") return ShigureDialogue.applyChoice(context, key);
 const c=S.chars[id];
    c.met=true;

    // プレイヤー台詞ログ
    const say = (txt)=>pushLog(`<span class="muted">提督</span>：「${txt}」`);

    if(key==="neutral"){
      say("ちょっと見回りだ。");
      if(S.suspect){
        if(chance(35)){ pushLog(`${c.name}は納得していない。`, "danger"); S.alert=clamp(S.alert+6); }
        else { pushLog(`${c.name}「……分かった」`, "muted"); c.trust=clamp(c.trust+1); }
      }else{
        pushLog(`${c.name}「そう。気をつけて」`, "muted");
        c.trust=clamp(c.trust+2);
        c.intimacy=clamp(c.intimacy+2);
      }
      return;
    }

    if(key==="lie"){
      say("眠れなくて散歩してた。");
      const lieP = S.suspect ? 55 : 25;
      if(chance(lieP)){
        pushLog(`${c.name}「……嘘の匂いがする」`, "danger");
        S.alert=clamp(S.alert+8);
        setSuspect("言い訳が不自然");
        c.trust=clamp(c.trust-3);
      }else{
        pushLog(`${c.name}「そう…なら、少し落ち着いて」`, "muted");
        c.trust=clamp(c.trust+1);
        c.intimacy=clamp(c.intimacy+3);
      }
      return;
    }

    if(key==="back"){
      say("悪い、戻る。");
      pushLog(`${c.name}は短く頷いた。`, "muted");
      S.alert = clamp(S.alert-3);
      c.trust = clamp(c.trust+1);
      return;
    }

    if(key==="explain"){
      say("誤解だ。理由がある。");
      const p = clamp(20 + (c.trust-40), 10, 75);
      if(chance(p)){
        pushLog(`${c.name}「……話は聞く」`, "ok");
        S.alert=clamp(S.alert-6);
        c.trust=clamp(c.trust+3);
      }else{
        pushLog(`${c.name}「理由になってない」`, "danger");
        S.alert=clamp(S.alert+6);
        c.trust=clamp(c.trust-2);
      }
      return;
    }

    if(key==="apologize"){
      say("疑わせたならすまない。");
      pushLog(`${c.name}「……次は気をつけて」`, "muted");
      S.alert=clamp(S.alert-6);
      c.trust=clamp(c.trust+4);
      c.intimacy=clamp(c.intimacy+1);
      return;
    }

    if(key==="soft"){
      say("心配してくれて助かる。");
      pushLog(`${c.name}は視線を少しだけ和らげた。`, "ok");
      c.trust=clamp(c.trust+2);
      c.intimacy=clamp(c.intimacy+6);
      if(c.intimacy>=100 && !c.bonded){ c.bonded=true; pushLog(`（${c.name}との関係が深くなった）`, "ok"); }
      return;
    }

    if(key==="join"){
      say("一緒に来てくれ。");
      const p = clamp(30 + (c.trust-60) + Math.floor(c.intimacy/10), 10, 85);
      if(chance(p)){
        pushLog(`${c.name}「……分かった。距離は保つ」`, "ok");
        if(!S.party.includes(id)) S.party.push(id);
        S.present = S.present.filter(o=>o.id!==id);
      }else{
        pushLog(`${c.name}「今は無理」`, "muted");
        c.trust=clamp(c.trust-1);
      }
      return;
    }
  }

  return { npcLine, options, applyChoice };
})();

/* =========================================================
   19) 起動処理とイベント配線
========================================================= */
function wireMenu(){
  const menuWrap=document.getElementById("menuWrap");
  document.getElementById("btnMenu").onclick=()=>menuWrap.classList.add("show");
  document.getElementById("menuClose").onclick=()=>menuWrap.classList.remove("show");
  document.getElementById("btnSave").onclick=saveLocal;
  document.getElementById("btnLoad").onclick=loadLocal;

  document.getElementById("btnRestart").onclick=()=>{
    menuWrap.classList.remove("show");
    newGame(false);
  };
  document.getElementById("btnReplay").onclick=()=>{
    menuWrap.classList.remove("show");
    const keep = S.seed;
    seed = keep;
    rnd = mulberry32(seed);
    S = defaultState();
    S.seed = seed;
    pushLog("—— <b>離島鎮守府</b> ——");
    pushLog("同じ潮、同じ夜。違う一手で抜けろ。<br><span class='muted'>（同条件リプレイ）</span>");
    enterLocation("hq");
    renderTop();
  };
  menuWrap.addEventListener("click",(e)=>{ if(e.target.id==="menuWrap") menuWrap.classList.remove("show"); });
}

function boot(){
  buildCmdButtons();
  wireMenu();
  newGame(false);
}

return { boot };

})(); // App end

// 起動
App.boot();
</script>
</body>
</html>
